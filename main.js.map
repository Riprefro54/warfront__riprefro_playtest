{"version":3,"file":"index.html","sections":[{"offset":{"line":1,"column":0},"map":{"version":3,"file":"main-bundle.js","mappings":"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","sources":["webpack://warfront-client/./src/ui/ModuleLoader.ts","webpack://warfront-client/./src/map/tile/TileType.ts","webpack://warfront-client/./src/map/tile/TileTypeIds.ts","webpack://warfront-client/./src/map/tile/WaterTile.ts","webpack://warfront-client/./src/map/tile/GrassTile.ts","webpack://warfront-client/./src/network/api/UserAccount.ts","webpack://warfront-client/./src/network/protocol/util/ProtocolUtils.ts","webpack://warfront-client/./src/network/api/Endpoint.ts","webpack://warfront-client/./src/network/api/UserAuthenticationRoutes.ts","webpack://warfront-client/./src/network/NetworkAuthenticator.ts","webpack://warfront-client/./src/util/CookieContext.ts","webpack://warfront-client/./src/util/PromiseBundle.ts","webpack://warfront-client/./src/util/PathHandler.ts","webpack://warfront-client/./src/Loader.ts","webpack://warfront-client/./src/map/TileManager.ts","webpack://warfront-client/./src/event/EventHandlerRegistry.ts","webpack://warfront-client/./src/game/GameTicker.ts","webpack://warfront-client/./src/ui/modules/GameHud-TopBar.ts","webpack://warfront-client/./src/ui/modules/GameHud.ts","webpack://warfront-client/./src/ui/modules/ImprintPanel.ts","webpack://warfront-client/./src/event/PrioritizedEventHandlerRegistry.ts","webpack://warfront-client/./src/event/InteractionManager.ts","webpack://warfront-client/./src/event/MapTransformHandler.ts","webpack://warfront-client/./src/game/action/MapNavigationHandler.ts","webpack://warfront-client/./src/util/MathUtil.ts","webpack://warfront-client/./src/util/PriorityQueue.ts","webpack://warfront-client/./src/game/Random.ts","webpack://warfront-client/./src/renderer/manager/PlayerNameRenderingManager.ts","webpack://warfront-client/./src/renderer/layer/CachedLayer.ts","webpack://warfront-client/./src/renderer/layer/TerritoryRenderer.ts","webpack://warfront-client/./src/renderer/manager/TerritoryRenderingManager.ts","webpack://warfront-client/./src/game/attack/AttackExecutor.ts","webpack://warfront-client/./src/game/attack/AttackActionHandler.ts","webpack://warfront-client/./src/game/player/Player.ts","webpack://warfront-client/./src/game/player/BotPlayer.ts","webpack://warfront-client/./src/game/player/SpawnManager.ts","webpack://warfront-client/./src/game/Game.ts","webpack://warfront-client/./src/game/player/PlayerManager.ts","webpack://warfront-client/./src/map/area/AreaCalculator.ts","webpack://warfront-client/./src/game/TerritoryManager.ts","webpack://warfront-client/./src/game/boat/Boat.ts","webpack://warfront-client/./src/map/area/BoatPathfinding.ts","webpack://warfront-client/./src/game/boat/BoatManager.ts","webpack://warfront-client/./src/game/action/MapActionHandler.ts","webpack://warfront-client/./src/renderer/shader/FixedDistanceShader.ts","webpack://warfront-client/./src/renderer/shader/DynamicDistanceShader.ts","webpack://warfront-client/./src/renderer/shader/ShaderManager.ts","webpack://warfront-client/./src/renderer/layer/MapRenderer.ts","webpack://warfront-client/./src/event/WindowResizeHandler.ts","webpack://warfront-client/./src/renderer/layer/BackgroundLayer.ts","webpack://warfront-client/./src/renderer/layer/NameRenderer.ts","webpack://warfront-client/./src/renderer/layer/BoatRenderer.ts","webpack://warfront-client/./src/renderer/GameRenderer.ts","webpack://warfront-client/./src/map/codec/src/util/ZoneCalculator.ts","webpack://warfront-client/./src/map/codec/src/MapEncoder.ts","webpack://warfront-client/./src/map/codec/src/util/StreamReader.ts","webpack://warfront-client/./src/map/codec/src/MapDecoder.ts","webpack://warfront-client/./src/map/GameMap.ts","webpack://warfront-client/./src/map/MapRegistry.ts","webpack://warfront-client/./src/game/mode/GameMode.ts","webpack://warfront-client/./src/game/mode/FFAGameMode.ts","webpack://warfront-client/./src/ui/modules/MainMenu.ts","webpack://warfront-client/./src/map/codec/MapCodec.ts","webpack://warfront-client/./src/ui/modules/PrivacyPanel.ts","webpack://warfront-client/./src/ui/modules/SettingsPanel.ts","webpack://warfront-client/./src/util/RGBColor.ts","webpack://warfront-client/./src/util/HSLColor.ts","webpack://warfront-client/./src/util/StringFormatter.ts","webpack://warfront-client/./src/util/SettingRegistry.ts","webpack://warfront-client/./src/renderer/GameTheme.ts","webpack://warfront-client/./src/util/UserSettingManager.ts","webpack://warfront-client/./src/util/exception/InvalidArgumentException.ts","webpack://warfront-client/./src/util/exception/UnsupportedDataException.ts","webpack://warfront-client/webpack/bootstrap","webpack://warfront-client/webpack/runtime/define property getters","webpack://warfront-client/webpack/runtime/hasOwnProperty shorthand","webpack://warfront-client/webpack/startup"],"sourcesContent":["import {getSetting, registerSettingListener} from \"../util/UserSettingManager\";\r\n\r\nconst modules = new Map<string, HTMLDivElement>();\r\nconst moduleAdapters = new Map<string, ModuleAdapter>();\r\nlet openModules: string[] = [];\r\n\r\ndocument.documentElement.classList.add(\"theme-\" + getSetting(\"theme\").id);\r\n\r\nregisterSettingListener(\"theme\", (theme) => {\r\n\tdocument.documentElement.classList.remove(\"theme-\" + getSetting(\"theme\").id);\r\n\tdocument.documentElement.classList.add(\"theme-\" + theme.id);\r\n});\r\n\r\nexport function openModule(name: string) {\r\n\tconst module = modules.get(name);\r\n\tif (module) {\r\n\t\tmoduleAdapters.get(name)!.onOpen();\r\n\t\tmodule.style.display = \"block\";\r\n\t\topenModules.push(name);\r\n\t}\r\n}\r\n\r\nexport function closeModule(name: string) {\r\n\tif (openModules.includes(name)) {\r\n\t\tmodules.get(name)!.style.display = \"none\";\r\n\t\topenModules = openModules.filter(item => item !== name);\r\n\t}\r\n}\r\n\r\nexport function closeAllModules() {\r\n\topenModules.forEach(module => {\r\n\t\tmodules.get(module)!.style.display = \"none\";\r\n\t});\r\n\topenModules = [];\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nfunction registerModule(name: string, adapter: ModuleAdapter) {\r\n\tconst element = document.getElementById(name) as HTMLDivElement;\r\n\telement.style.display = \"none\";\r\n\tmodules.set(name, element);\r\n\tmoduleAdapters.set(name, adapter ?? {onOpen: () => {}});\r\n}\r\n\r\n// The following lines are filled in by the build process\r\nwindow.addEventListener(\"load\", function () {\nregisterModule(\"GameHud-TopBar\", require(\"./modules/GameHud-TopBar.ts\").default);\nregisterModule(\"GameHud\", require(\"./modules/GameHud.ts\").default);\nregisterModule(\"ImprintPanel\", require(\"./modules/ImprintPanel.ts\").default);\nregisterModule(\"MainMenu\", require(\"./modules/MainMenu.ts\").default);\nregisterModule(\"PrivacyPanel\", require(\"./modules/PrivacyPanel.ts\").default);\nregisterModule(\"SettingsPanel\", require(\"./modules/SettingsPanel.ts\").default);\n});\r\n// End of module register block\r\n\r\nexport type ModuleAdapter = {\r\n\tonOpen: () => void;\r\n}","import {HSLColor} from \"../../util/HSLColor\";\r\n\r\n/**\r\n * Tile types are used to define the properties of a tile.\r\n * They are used to render the map and to determine the behavior of the tile.\r\n *\r\n * Tile types are immutable and should be created once and then reused.\r\n * Subclasses mustn't have any mutable state.\r\n */\r\nexport abstract class TileType {\r\n\tabstract readonly id: number;\r\n\tabstract readonly internalName: string;\r\n\tabstract readonly baseColor: HSLColor;\r\n\tabstract readonly isSolid: boolean;\r\n\t/** The relative time it takes to expand the tile, 0-255 higher meaning slower, 50 being the default */\r\n\treadonly expansionTime: number = 50;\r\n\t/** The relative cost to expand the tile, 0-255 higher meaning more expensive, 50 being the default */\r\n\treadonly expansionCost: number = 50;\r\n\r\n\t//TODO: This is a placeholder for now\r\n\t// tile types should be able to render sprites or other graphics when zoomed in enough\r\n\tabstract render(context: CanvasRenderingContext2D, x: number, y: number): void;\r\n}","/**\r\n * Tile type IDs are used to identify tile types in storage and game logic.\r\n *\r\n * Certain ranges of tile type IDs are reserved for specific purposes:\r\n * - 0-1023: Tile type IDs for built-in tile types\r\n * - 1024-2047: Tile type IDs for custom tile types (reserved for user-defined tile types)\r\n * - 2048-16383: Tile type IDs for 3rd party applications (e.g. mods) to avoid conflicts with built-in and custom tile types\r\n * - 16384-32767: Tile type IDs for internal use (e.g. temporary tile types, player territory aliases)\r\n * - 32768-65535: Reserved for future use\r\n *\r\n * Do not change the order of the enum values (TypeScript implicitly assigns numbers to enum values).\r\n */\r\nexport enum TileTypeIds {\r\n\tWATER,\r\n\tGRASS\r\n}","import {TileType} from \"./TileType\";\r\nimport {TileTypeIds} from \"./TileTypeIds\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\n\r\nexport class WaterTile extends TileType {\r\n\treadonly id: number = TileTypeIds.WATER;\r\n\treadonly internalName = \"water\";\r\n\treadonly baseColor: HSLColor = HSLColor.fromRGB(0, 0, 200);\r\n\treadonly isSolid: boolean = false;\r\n\r\n\trender(_context: CanvasRenderingContext2D, _x: number, _y: number): void {\r\n\t\t//TODO sprite ?\r\n\t}\r\n}","import {TileType} from \"./TileType\";\r\nimport {TileTypeIds} from \"./TileTypeIds\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\n\r\nexport class GrassTile extends TileType {\r\n\treadonly id: number = TileTypeIds.GRASS;\r\n\treadonly internalName = \"grass\";\r\n\treadonly baseColor: HSLColor = HSLColor.fromRGB(40, 200, 20);\r\n\treadonly isSolid: boolean = true;\r\n\r\n\trender(_context: CanvasRenderingContext2D, _x: number, _y: number): void {\r\n\t\t//TODO sprite ?\r\n\t}\r\n}","import {EventHandlerRegistry} from \"../../event/EventHandlerRegistry\";\r\nimport {apiToUserAccount, APIUserAccount, UserAccount} from \"../protocol/util/ProtocolUtils\";\r\n\r\nlet userAccount: UserAccount | null = null;\r\n\r\n/**\r\n * Updates the current user account\r\n * @param account new account\r\n * @internal\r\n */\r\nexport function updateUserAccount(account: APIUserAccount | null) {\r\n\tif (userAccount === account) return;\r\n\tif (account === null || userAccount === null || account.id !== userAccount.id || account.username !== userAccount.username || account.avatar_url !== userAccount.avatarURL) {\r\n\t\tuserAccount = account === null ? null : apiToUserAccount(account);\r\n\t\taccountSwitchHandler.broadcast();\r\n\t}\r\n}\r\n\r\n/**\r\n * Gets the current user account\r\n * NOTE: For display purposes use the registry below instead\r\n */\r\nexport function getUserAccount(): UserAccount | null {\r\n\treturn userAccount;\r\n}\r\n\r\nexport const accountSwitchHandler: EventHandlerRegistry<[UserAccount | null]> = new EventHandlerRegistry(true, listener => listener(userAccount));","export type UserAccount = {\r\n\treadonly id: string;\r\n\t/** authentication service */\r\n\treadonly service: string;\r\n\t/** user ID on the service */\r\n\treadonly serviceId: string;\r\n\treadonly username: string;\r\n\treadonly avatarURL: string;\r\n};\r\nexport type APIUserAccount = {\r\n\tid: string;\r\n\tservice: string;\r\n\tuser_id: string;\r\n\tusername: string;\r\n\tavatar_url: string;\r\n};\r\n\r\n/**\r\n * Converts an API user account to a user account.\r\n * We use snake_case for API fields and camelCase for internal fields.\r\n * @param account API user account\r\n */\r\nexport function apiToUserAccount(account: APIUserAccount): UserAccount {\r\n\treturn {\r\n\t\tid: account.id,\r\n\t\tservice: account.service,\r\n\t\tserviceId: account.user_id,\r\n\t\tusername: account.username,\r\n\t\tavatarURL: account.avatar_url\r\n\t};\r\n}","import {getUserToken} from \"../NetworkAuthenticator\";\r\nimport {getSetting} from \"../../util/UserSettingManager\";\r\n\r\n/**\r\n * Constructs a get endpoint function.\r\n * @param url Base URL\r\n * @param auth Whether to use authentication\r\n */\r\nexport function endpointGET<T extends string>(url: T, auth: boolean = false) {\r\n\treturn function <P extends Record<string, string>, R extends { [key: number]: unknown }>() {\r\n\t\treturn function (params: P & ExtractParams<T>): APIResponse<R, never> {\r\n\t\t\treturn APIResponse.get<R>(fillPathParams(url, params), params, auth);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Constructs a post endpoint function.\r\n * @param url Base URL\r\n * @param auth Whether to use authentication\r\n */\r\nexport function endpointPOST<T extends string>(url: T, auth: boolean = false) {\r\n\treturn function <P extends Record<string, string>, R extends { [key: number]: unknown }>() {\r\n\t\treturn function (params: P & ExtractParams<T>): APIResponse<R, never> {\r\n\t\t\treturn APIResponse.post<R>(fillPathParams(url, params), params, auth);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Fills the path parameters in the URL with the given parameters and removes them from the object\r\n * @param url URL to fill\r\n * @param params Parameters to fill the URL with\r\n */\r\nfunction fillPathParams<T extends string, U extends ExtractParams<T> & Record<string, string>>(url: T, params: U) {\r\n\treturn url.replace(/{([^}]+)}/g, (_, key: keyof U) => {\r\n\t\tconst value = params[key];\r\n\t\tdelete params[key];\r\n\t\treturn value;\r\n\t});\r\n}\r\n\r\nclass APIResponse<T extends { [key: number]: unknown }, E extends keyof T> {\r\n\tprivate listeners: { [K in keyof T]?: ((data: T[K]) => void) } = {};\r\n\tprivate errorListener: ((data: { [K in keyof T]: { error: false, code: K, data: T[K] } }[keyof T] | { error: true, data: unknown }) => void) | null = null;\r\n\tprivate result: { [K in keyof T]: { error: false, code: K, data: T[K] } }[keyof T] | { error: true, data: unknown } | null = null;\r\n\r\n\tconstructor(url: string, options: Promise<RequestInit>) {\r\n\t\toptions.then(options => {\r\n\t\t\tfetch(getSetting(\"api-location\") + url, options).then(response => {\r\n\t\t\t\tif (response.headers.get(\"Content-Type\") === \"application/json\") {\r\n\t\t\t\t\tresponse.json().then(data => {\r\n\t\t\t\t\t\tthis.handleResponse(response.status as keyof T, data as T[keyof T]);\r\n\t\t\t\t\t}).catch(this.handleError.bind(this));\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//Let's assume (hope) that the response is text\r\n\t\t\t\t\tresponse.text().then(data => {\r\n\t\t\t\t\t\tthis.handleResponse(response.status as keyof T, data as T[keyof T]);\r\n\t\t\t\t\t}).catch(this.handleError.bind(this));\r\n\t\t\t\t}\r\n\t\t\t}).catch(this.handleError.bind(this));\r\n\t\t}).catch(this.handleError.bind(this))\r\n\t}\r\n\r\n\t/**\r\n\t * Handles the response from the server.\r\n\t * @param status Status code of the response\r\n\t * @param data Data of the response\r\n\t * @private\r\n\t */\r\n\tprivate handleResponse<K extends keyof T>(status: K, data: T[K]) {\r\n\t\tconst listener = this.listeners[status];\r\n\t\tif (listener) {\r\n\t\t\tlistener(data);\r\n\t\t} else if (this.errorListener) {\r\n\t\t\tthis.errorListener({error: false, code: status, data} as { error: false, code: K, data: T[K] });\r\n\t\t}\r\n\t\tthis.result = {error: false, code: status, data} as { error: false, code: K, data: T[K] };\r\n\t}\r\n\r\n\t/**\r\n\t * Handles an error during the request.\r\n\t * @param error Error that occurred\r\n\t * @private\r\n\t */\r\n\tprivate handleError(error: unknown) {\r\n\t\tif (this.errorListener) {\r\n\t\t\tthis.errorListener({error: true, data: error});\r\n\t\t}\r\n\t\tthis.result = {error: true, data: error};\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a listener for the given status code.\r\n\t * @param status Status code to listen for\r\n\t * @param callback Callback to call when the status code is received\r\n\t */\r\n\ton<K extends keyof T>(status: K & Exclude<K, E>, callback: (data: T[K]) => void) {\r\n\t\t//Note: We assign the listener even if we already have a result, because it might be important to the error listener\r\n\t\tthis.listeners[status] = callback;\r\n\r\n\t\tif (this.result) {\r\n\t\t\tif (!this.result.error && this.result.code === status) {\r\n\t\t\t\tcallback(this.result.data as T[K]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this as APIResponse<T, E | K>;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a listener for any unhanded status code or error.\r\n\t * @param callback Callback to call when an unhandled status code is received\r\n\t */\r\n\tcatch(callback: (data: { [K in keyof T]: { error: false, code: K, data: T[K] } }[keyof T] | { error: true, data: unknown }) => void) {\r\n\t\tif (this.result) {\r\n\t\t\tcallback(this.result);\r\n\t\t} else {\r\n\t\t\tthis.errorListener = callback;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sends a GET request to the given URL with the given parameters.\r\n\t * @param url URL to send the request to\r\n\t * @param params query parameters to send\r\n\t * @param auth Whether to use authentication\r\n\t */\r\n\tstatic get<T extends { [key: number]: unknown }>(url: string, params: Record<string, string>, auth: boolean) {\r\n\t\tconst options = {method: \"GET\"};\r\n\t\treturn new APIResponse<T, never>(url + \"?\" + (new URLSearchParams(params)).toString(), auth ? getUserToken().refresh().then(token => token.addAuth(options)) : Promise.resolve(options));\r\n\t}\r\n\r\n\t/**\r\n\t * Sends a POST request to the given URL with the given parameters.\r\n\t * @param url URL to send the request to\r\n\t * @param params body parameters to send\r\n\t * @param auth Whether to use authentication\r\n\t */\r\n\tstatic post<T extends { [key: number]: unknown }>(url: string, params: Record<string, string>, auth: boolean) {\r\n\t\tconst options = {method: \"POST\", body: new URLSearchParams(params), headers: {\"Content-Type\": \"application/x-www-form-urlencoded\"}};\r\n\t\treturn new APIResponse<T, never>(url, auth ? getUserToken().refresh().then(token => token.addAuth(options)) : Promise.resolve(options));\r\n\t}\r\n}\r\n\r\ntype ExtractParams<T extends string> = T extends `${infer _}{${infer P}}${infer R}` ? Record<P, string> & ExtractParams<R> : {};","import {endpointPOST} from \"./Endpoint\";\r\nimport {getSetting} from \"../../util/UserSettingManager\";\r\nimport {APIUserAccount} from \"../protocol/util/ProtocolUtils\";\r\n\r\n/**\r\n * Redirects the user to the login page for the given service\r\n * @param service The service to log in with\r\n * @param state The state to use for the login\r\n * @internal Use {@link login} instead\r\n */\r\nexport function loginUser(service: \"discord\", state: string) {\r\n\twindow.location.href = getSetting(\"api-location\") + \"/login/\" + service + \"/?state=\" + state;\r\n}\r\n\r\n/**\r\n * Request a new refresh token using authentication code.\r\n * @param token The authentication code\r\n * @internal\r\n */\r\nexport const requestToken = endpointPOST(\"/token/\")<{ token: string }, { 200: string, 400: void, 401: string, 500: string }>();\r\n\r\n/**\r\n * Request a new access token using the refresh token, this will invalidate the old access token.\r\n * @param token The refresh token\r\n * @internal\r\n */\r\nexport const refreshToken = endpointPOST(\"/token/\")<{ token: string }, { 200: { access_token: string, expires_in: number, refresh_token: string, user: APIUserAccount }, 400: void, 401: string, 500: string }>();\r\n\r\n/**\r\n * Request a new external access token for the given host.\r\n * @param host The host to request the token for\r\n */\r\nexport const requestTokenExternal = endpointPOST(\"/token/external/\", true)<{ host: string }, { 200: string, 400: void, 401: string, 500: void }>();\r\n\r\n/**\r\n * Revoke the refresh token, this will invalidate the specified refresh token.\r\n * @param token The refresh token\r\n */\r\nexport const revokeToken = endpointPOST(\"/revoke/\")<{ token: string }, { 200: void, 400: void }>();\r\n\r\n/**\r\n * Logout the user. Other than revoke, this invalidates all refresh tokens for the user.\r\n */\r\nexport const logoutUser = endpointPOST(\"/logout/\", true)<{}, { 200: void, 401: string }>();","import {buildPromiseBundle} from \"../util/PromiseBundle\";\r\nimport {CookieContext} from \"../util/CookieContext\";\r\nimport {updateUserAccount} from \"./api/UserAccount\";\r\nimport {loginUser, refreshToken, revokeToken} from \"./api/UserAuthenticationRoutes\";\r\nimport {InvalidArgumentException} from \"../util/exception/InvalidArgumentException\";\r\nimport {openModule} from \"../ui/ModuleLoader\";\r\n\r\ntype UserToken = {\r\n\t/**\r\n\t * Refreshes the user token if necessary.\r\n\t */\r\n\trefresh: () => Promise<UserToken>;\r\n\t/**\r\n\t * Adds authentication to a request configuration.\r\n\t * @param conf The request configuration (without authentication)\r\n\t * @returns The request configuration with authentication (if necessary)\r\n\t */\r\n\taddAuth: (conf: RequestInit) => RequestInit;\r\n\t/**\r\n\t * Gets the raw token.\r\n\t */\r\n\tgetRawToken: () => string | undefined;\r\n};\r\n\r\nclass ActualUserToken implements UserToken {\r\n\tconstructor(private token: string, private expires: number) {}\r\n\r\n\trefresh(): Promise<UserToken> {\r\n\t\tif (Date.now() < this.expires) {\r\n\t\t\treturn Promise.resolve(this);\r\n\t\t}\r\n\t\treturn fetchUserToken();\r\n\t}\r\n\r\n\taddAuth(conf: RequestInit): RequestInit {\r\n\t\treturn {\r\n\t\t\t...conf,\r\n\t\t\theaders: {\r\n\t\t\t\t...conf.headers,\r\n\t\t\t\tAuthorization: `Bearer ${this.token}`\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tgetRawToken(): string {\r\n\t\treturn this.token;\r\n\t}\r\n}\r\n\r\nclass InvalidUserToken implements UserToken {\r\n\trefresh(): Promise<UserToken> {\r\n\t\treturn Promise.resolve(this);\r\n\t}\r\n\r\n\taddAuth(conf: RequestInit): RequestInit {\r\n\t\treturn conf;\r\n\t}\r\n\r\n\tgetRawToken(): undefined {\r\n\t\treturn undefined;\r\n\t}\r\n}\r\n\r\nlet userToken: UserToken = new ActualUserToken(\"\", 0); // Dummy token to cause a fetch on first use\r\n\r\nconst refreshTokenCookie = new CookieContext(\"token\");\r\n\r\n/**\r\n * Gets the current user token.\r\n * @returns The user token\r\n */\r\nexport function getUserToken(): UserToken {\r\n\treturn userToken;\r\n}\r\n\r\n/**\r\n * Fetches the user token.\r\n * @returns Promise that resolves to the user token\r\n */\r\nconst fetchUserToken = buildPromiseBundle(() => {\r\n\treturn new Promise<UserToken>((resolve) => {\r\n\t\ttryFetchUserToken(resolve, 0);\r\n\t});\r\n});\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction tryFetchUserToken(resolve: (token: UserToken) => void, retries: number) {\r\n\tconst token = refreshTokenCookie.get();\r\n\tif (token === null) {\r\n\t\tupdateUserAccount(null);\r\n\t\tresolve(userToken = new InvalidUserToken());\r\n\t\treturn;\r\n\t}\r\n\trefreshToken({token})\r\n\t\t.on(200, data => {\r\n\t\t\trefreshTokenCookie.forceSet(data.refresh_token, 29);\r\n\t\t\tupdateUserAccount(data.user);\r\n\t\t\tresolve(userToken = new ActualUserToken(data.access_token, Date.now() + data.expires_in * 1000));\r\n\t\t})\r\n\t\t.on(401, () => {\r\n\t\t\t// Another tab might have refreshed the token while we were waiting for the response.\r\n\t\t\tif (refreshTokenCookie.set(\"\", -1)) {\r\n\t\t\t\tupdateUserAccount(null);\r\n\t\t\t\tresolve(userToken = new InvalidUserToken());\r\n\t\t\t} else {\r\n\t\t\t\tif (retries < 3) {\r\n\t\t\t\t\ttryFetchUserToken(resolve, retries + 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.warn(\"Failed to fetch user token after 3 retries\");\r\n\t\t\t\t\tupdateUserAccount(null);\r\n\t\t\t\t\tresolve(userToken = new InvalidUserToken());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\t.catch(err => {\r\n\t\t\tconsole.warn(\"Failed to fetch user token\");\r\n\t\t\tconsole.log(err);\r\n\t\t\tupdateUserAccount(null);\r\n\t\t\tresolve(userToken = new InvalidUserToken());\r\n\t\t});\r\n}\r\n\r\n/**\r\n * Awaits the user token to be fetched.\r\n * Make sure to use this if processes could interfere with the token fetch.\r\n * This will prevent requesting a new token and as such invalidate the current one without managing to store the new one.\r\n * Actions such as redirecting the user to a different page should be delayed until the token is fetched.\r\n * @returns Promise that resolves when the user token is fetched\r\n */\r\nexport function awaitSafeForward(): Promise<void> {\r\n\tif (fetchUserToken.isPending()) {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tfetchUserToken().then(() => resolve()).catch((e: Error) => reject(e));\r\n\t\t});\r\n\t}\r\n\treturn Promise.resolve();\r\n}\r\n\r\nexport function login(service: \"discord\") {\r\n\tconst state = Math.random().toString(36).substring(2, 15);\r\n\tawaitSafeForward().then(() => {\r\n\t\tsessionStorage.setItem(\"authState\", state);\r\n\t\tloginUser(service, state);\r\n\t}).catch(() => {});\r\n}\r\n\r\n/**\r\n * Logs out the user.\r\n */\r\nexport function logout() {\r\n\trevokeToken({token: refreshTokenCookie.get() ?? \"\"})\r\n\trefreshTokenCookie.forceSet(\"\", -1);\r\n\tuserToken = new InvalidUserToken();\r\n\tupdateUserAccount(null);\r\n}\r\n\r\n/**\r\n * Handles the authentication callback.\r\n * @param params The URL parameters\r\n * @param _path The path\r\n * @throws InvalidArgumentException If the parameters are invalid\r\n */\r\nexport function handleAuthCallback(params: URLSearchParams, _path: string[]) {\r\n\tconst token = params.get(\"token\");\r\n\tconst state = params.get(\"state\");\r\n\tif (token === null) {\r\n\t\tthrow new InvalidArgumentException(\"Missing token\");\r\n\t}\r\n\tif (state === null || sessionStorage.getItem(\"authState\") === null || state !== sessionStorage.getItem(\"authState\")) {\r\n\t\tthrow new InvalidArgumentException(\"State mismatch\");\r\n\t}\r\n\trefreshTokenCookie.forceSet(token, 29);\r\n\tsessionStorage.removeItem(\"authState\");\r\n\twindow.history.replaceState(null, \"\", \"/\");\r\n\t//TODO: Show a tooltip that the user was logged in\r\n\topenModule(\"MainMenu\");\r\n}","/**\r\n * Reduces the chance of accidentally overwriting a cookie value that was changed by another script.\r\n * Since cookies (like most things in JavaScript) do not provide a proper mutex, this sadly does not fully prevent race conditions.\r\n *\r\n * WARNING: Only call a chain of both methods in a synchronous context.\r\n * That means nothing else should access this context in between the get and set calls.\r\n */\r\nexport class CookieContext {\r\n\tprivate lastSeenValue: string | null = null;\r\n\r\n\tconstructor(private cookie: string) {}\r\n\r\n\t/**\r\n\t * Gets the cookie value.\r\n\t */\r\n\tget(): string | null {\r\n\t\treturn this.lastSeenValue = this.fetchValue();\r\n\t}\r\n\r\n\tprivate fetchValue(): string | null {\r\n\t\tconst matches = document.cookie.match(new RegExp(`(^|;)\\\\s*${this.cookie}\\\\s*=\\\\s*([^;]+)`));\r\n\t\tif (matches) {\r\n\t\t\treturn matches.pop() as string;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the cookie value.\r\n\t * @param value new value\r\n\t * @param lifetime The lifetime of the cookie in days.\r\n\t * @returns Whether the value was set successfully.\r\n\t */\r\n\tset(value: string, lifetime: number): boolean {\r\n\t\tif (this.lastSeenValue !== this.fetchValue()) {\r\n\t\t\t/**\r\n\t\t\t * The value of the cookie has changed since the last time we checked.\r\n\t\t\t * This means that the cookie was changed by another script, e.g. on another tab.\r\n\t\t\t * We do not want to overwrite the value in this case.\r\n\t\t\t */\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tthis.forceSet(value, lifetime);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Forces the cookie value to be set.\r\n\t * WARNING: This will overwrite any changes made by other scripts.\r\n\t * @param value new value\r\n\t * @param lifetime The lifetime of the cookie in days.\r\n\t */\r\n\tforceSet(value: string, lifetime: number): void {\r\n\t\tdocument.cookie = `${this.cookie}=${value}; expires=${new Date(Date.now() + lifetime * 24 * 60 * 60 * 1000).toUTCString()}; path=/; SameSite=Strict; Secure`;\r\n\t}\r\n}","/**\r\n * Util to provide a reusable promise, only executing the method once at a time.\r\n */\r\nexport function buildPromiseBundle<T extends unknown[], R>(method: ((...args: T) => Promise<R>)) {\r\n\tlet promise: Promise<R> | undefined;\r\n\r\n\tconst func: ((...args: T) => Promise<R>) & { isPending: () => boolean } = (...args: T) => {\r\n\t\tif (!promise) {\r\n\t\t\tpromise = method(...args);\r\n\t\t\tpromise.then(() => {\r\n\t\t\t\tpromise = undefined;\r\n\t\t\t}).catch(() => {\r\n\t\t\t\tpromise = undefined;\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn promise;\r\n\t};\r\n\tfunc.isPending = () => !!promise;\r\n\treturn func;\r\n}","import {handleAuthCallback} from \"../network/NetworkAuthenticator\";\r\nimport {openModule} from \"../ui/ModuleLoader\";\r\n\r\nconst paths: Record<string, (params: URLSearchParams, path: string[]) => void> = {\r\n\tauth: handleAuthCallback\r\n};\r\n\r\n/**\r\n * Handle the current path.\r\n */\r\nexport function handlePath(): void {\r\n\tconst path = window.location.pathname.match(/\\/([^/]+)/);\r\n\tif (path === null || path[1] === undefined || !(path[1] in paths)) {\r\n\t\twindow.history.replaceState(null, \"\", \"/\");\r\n\t\topenModule(\"MainMenu\");\r\n\t\treturn;\r\n\t}\r\n\ttry {\r\n\t\tconst params = new URLSearchParams(window.location.search);\r\n\t\tpaths[path[1]](params, path.slice(2));\r\n\t} catch (e) {\r\n\t\tconsole.error(e);\r\n\t\twindow.history.replaceState(null, \"\", \"/\");\r\n\t\topenModule(\"MainMenu\");\r\n\t}\r\n}","import {TileManager} from \"./map/TileManager\";\r\n\r\nexport const tileManager = new TileManager();\r\nimport {handlePath} from \"./util/PathHandler\";\r\n\r\nwindow.addEventListener(\"load\", () => {\r\n\thandlePath();\r\n});","import {TileType} from \"./tile/TileType\";\r\nimport {WaterTile} from \"./tile/WaterTile\";\r\nimport {GrassTile} from \"./tile/GrassTile\";\r\nimport {UnsupportedDataException} from \"../util/exception/UnsupportedDataException\";\r\n\r\nexport class TileManager {\r\n\tprivate tileTypes: TileType[] = [];\r\n\r\n\tconstructor() {\r\n\t\tthis.registerTileType(new WaterTile());\r\n\t\tthis.registerTileType(new GrassTile());\r\n\t}\r\n\r\n\t/**\r\n\t * Registers a tile type\r\n\t *\r\n\t * Make sure to use the proper tile type ids\r\n\t * Only one tile type can be registered per id\r\n\t * @see TileTypeIds\r\n\t * @param tileType the tile type to register\r\n\t * @throws UnsupportedDataException if a tile type with the same id is already registered\r\n\t */\r\n\tregisterTileType(tileType: TileType): void {\r\n\t\tif (this.tileTypes[tileType.id] !== undefined) {\r\n\t\t\tthrow new UnsupportedDataException(\"TileType with id \" + tileType.id + \" already registered\")\r\n\t\t}\r\n\t\tthis.tileTypes[tileType.id] = tileType;\r\n\t}\r\n\r\n\t// noinspection JSUnusedGlobalSymbols - util for 3rd party code\r\n\t/**\r\n\t * Allows 3rd party code to override a tile type\r\n\t *\r\n\t * Allows mods to overwrite rendering portions of a built-in tile type\r\n\t * Requires non-visual tile data to match the original tile type\r\n\t *\r\n\t * @param tileType the tile type to override\r\n\t * @throws UnsupportedDataException if the tile type is not registered or data does not match\r\n\t */\r\n\toverrideTileType(tileType: TileType): void {\r\n\t\tconst existingTileType = this.tileTypes[tileType.id];\r\n\t\tif (existingTileType === undefined) {\r\n\t\t\tthrow new UnsupportedDataException(\"TileType with id \" + tileType.id + \" not registered\")\r\n\t\t}\r\n\t\tif (existingTileType.isSolid !== tileType.isSolid) {\r\n\t\t\tthrow new UnsupportedDataException(\"TileType with id \" + tileType.id + \" isSolid does not match\")\r\n\t\t}\r\n\t\tthis.tileTypes[tileType.id] = tileType;\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves a tile type by its id\r\n\t *\r\n\t * @param id the id of the tile type\r\n\t * @returns the tile type\r\n\t */\r\n\tfromID(id: number): TileType {\r\n\t\treturn this.tileTypes[id];\r\n\t}\r\n}","/**\r\n * Simple event handler registry for managing event listeners.\r\n * Mainly used to manage game event listeners.\r\n */\r\nexport class EventHandlerRegistry<T extends unknown[]> {\r\n\tprotected listeners: ((this: void, ...args: T) => void)[] = [];\r\n\r\n\t/**\r\n\t * Creates a new event handler registry.\r\n\t * @param callImmediately If true, the handleListener method is called for each listener immediately after registration.\r\n\t * @param handleListener The method to call on each listener.\r\n\t */\r\n\tconstructor(\r\n\t\tprivate readonly callImmediately: boolean = false,\r\n\t\tprivate readonly handleListener: (listener: (this: void, ...args: T) => void) => void\r\n\t) {}\r\n\r\n\t/**\r\n\t * Registers a listener to receive events.\r\n\t * If callImmediately is true, the listener is called immediately after registration (e.g. for initialization).\r\n\t * Note: you most likely have to bind the listener to the correct context or specify \"this: void\" in the listener.\r\n\t * @param listener The listener to register.\r\n\t */\r\n\tregister(listener: (this: void, ...args: T) => void) {\r\n\t\tthis.listeners.push(listener);\r\n\t\tif (this.callImmediately) {\r\n\t\t\tthis.handleListener(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Unregisters a listener to no longer receive events.\r\n\t * @param listener The listener to unregister.\r\n\t */\r\n\tunregister(listener: (this: void, ...args: T) => void) {\r\n\t\tthis.listeners = this.listeners.filter(l => l !== listener);\r\n\t}\r\n\r\n\t/**\r\n\t * Broadcasts an event to all registered listeners.\r\n\t * @internal Only call this method if you are the event source.\r\n\t */\r\n\tbroadcast() {\r\n\t\tthis.listeners.forEach(this.handleListener);\r\n\t}\r\n}","import {EventHandlerRegistry} from \"../event/EventHandlerRegistry\";\r\n\r\nclass GameTicker {\r\n\tprivate readonly TICK_INTERVAL = 1000 / 20; // 50ms\r\n\tprivate ticker: NodeJS.Timeout;\r\n\tprivate tickCount: number;\r\n\r\n\t/**\r\n\t * Registry for game tick listeners.\r\n\t * Game tick listeners are called once per game tick allowing for game logic to be updated.\r\n\t *\r\n\t * Format: () => void\r\n\t */\r\n\tregistry: EventHandlerRegistry<[]> = new EventHandlerRegistry(false, listener => listener());\r\n\r\n\t/**\r\n\t * Starts and resets the game ticker.\r\n\t * Do not call this to implement a pause behavior.\r\n\t * @internal\r\n\t */\r\n\tstart() {\r\n\t\tthis.tickCount = 0;\r\n\t\tthis.ticker = setInterval(() => this.tick(), this.TICK_INTERVAL);\r\n\t}\r\n\r\n\t/**\r\n\t * Stops the game ticker.\r\n\t * Do not call this to implement a pause behavior.\r\n\t * @internal\r\n\t */\r\n\tstop() {\r\n\t\tclearInterval(this.ticker);\r\n\t}\r\n\r\n\tprivate tick() {\r\n\t\tthis.tickCount++;\r\n\t\tthis.registry.broadcast();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the current tick count.\r\n\t *\r\n\t * Do not use this to calculate time differences.\r\n\t * There is no guarantee that the ticker runs at a constant rate.\r\n\t * @returns The current tick count.\r\n\t */\r\n\tgetTickCount(): number {\r\n\t\treturn this.tickCount;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the elapsed in-game-time in milliseconds.\r\n\t * Note that this is not necessarily the same as the real-world time.\r\n\t * @returns The elapsed in-game-time in milliseconds.\r\n\t */\r\n\tgetElapsedTime(): number {\r\n\t\treturn this.tickCount * this.TICK_INTERVAL;\r\n\t}\r\n}\r\n\r\nexport const gameTicker = new GameTicker();","import {gameTicker} from \"../../game/GameTicker\";\r\nimport {formatTime} from \"../../util/StringFormatter\";\r\nimport {getSetting, registerSettingListener} from \"../../util/UserSettingManager\";\r\nimport {ModuleAdapter} from \"../ModuleLoader\";\r\nimport {openModule} from \"../ModuleLoader\";\r\n\r\nconst gameClock: HTMLElement = (window.document.getElementById(\"gameClock\") as HTMLElement);\r\nconst lblGameTime: HTMLElement = (window.document.getElementById(\"lblGameTime\") as HTMLElement);\r\n\r\nexport default {\r\n\tonOpen: () => {\r\n\t\t// Initialize elements according to user settings\r\n\t\tgameClock.style.display = getSetting(\"gameHud-clock\") ? \"inherit\" : \"none\";\r\n\t}\r\n} as ModuleAdapter;\r\n\r\ngameTicker.registry.register(() => lblGameTime.innerHTML = formatTime(gameTicker.getElapsedTime()));\r\nregisterSettingListener(\"gameHud-clock\", show => gameClock.style.display = show ? \"inherit\" : \"none\");\r\n\r\n\r\n(window as any).commandShowSettings = function () {\r\n\topenModule(\"SettingsPanel\");\r\n};\r\n\r\n(window as any).commandExitGame = function () {\r\n\twindow.location.reload();\r\n};\r\n","import {ModuleAdapter} from \"../ModuleLoader\";\r\nimport {openModule} from \"../ModuleLoader\";\r\n\r\nexport default {\r\n\tonOpen: () => {\r\n\t\topenModule(\"GameHud-TopBar\");\r\n\t}\r\n} as ModuleAdapter;","import {closeModule} from \"../ModuleLoader\";\r\n\r\n(window as any).commandCloseImprintPanel = function () {\r\n\tcloseModule(\"ImprintPanel\");\r\n};","import {BasicInteractionListener} from \"./InteractionManager\";\r\n\r\n/**\r\n * Registry for prioritized event handlers.\r\n * Event handlers are called in the order they were registered (if not prioritized).\r\n * The first handler that returns true for the test method is chosen.\r\n * Use this for non-propagating event handling (e.g. click events).\r\n */\r\nexport class PrioritizedEventHandlerRegistry<T extends BasicInteractionListener> {\r\n\tprotected listeners: T[] = [];\r\n\tprivate currentListener: T | null = null;\r\n\r\n\t/**\r\n\t * Registers a listener to receive events.\r\n\t * @param listener The listener to register.\r\n\t * @param prioritize If true, the listener is added to the beginning of the stack instead of the end.\r\n\t */\r\n\tregister(listener: T, prioritize: boolean = false) {\r\n\t\tif (prioritize) {\r\n\t\t\tthis.listeners.unshift(listener);\r\n\t\t} else {\r\n\t\t\tthis.listeners.push(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Unregisters a listener to no longer receive events.\r\n\t * @param listener The listener to unregister.\r\n\t */\r\n\tunregister(listener: T) {\r\n\t\tthis.listeners = this.listeners.filter(l => l !== listener);\r\n\t}\r\n\r\n\t/**\r\n\t * Resets current active listener.\r\n\t * Some events require to keep track of the current listener, since their events are not fired at the same positions.\r\n\t * Call this method after the event has been handled to prevent the same listener from being called again.\r\n\t */\r\n\treset(): void {\r\n\t\tthis.currentListener = null;\r\n\t}\r\n\r\n\t/**\r\n\t * Chooses the listener to receive events.\r\n\t * The first listener that returns true for the test method is chosen.\r\n\t * @param x The x coordinate of the event.\r\n\t * @param y The y coordinate of the event.\r\n\t */\r\n\tchoose(x: number, y: number): void {\r\n\t\tthis.currentListener = this.listeners.find(l => l.test(x, y)) || null;\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the listener that was chosen by the choose method.\r\n\t * If no listener was chosen, nothing happens.\r\n\t * @param handler closure to call on the chosen listener.\r\n\t */\r\n\tcall(handler: (listener: T) => void): void {\r\n\t\tif (this.currentListener) {\r\n\t\t\thandler(this.currentListener);\r\n\t\t}\r\n\t}\r\n}","import {PrioritizedEventHandlerRegistry} from \"./PrioritizedEventHandlerRegistry\";\r\n\r\n/**\r\n * Manages interactions with the user.\r\n * This includes click, drag, scroll and hover events.\r\n *\r\n * All these events only apply to the topmost element at the given position.\r\n * @see PrioritizedEventHandlerRegistry\r\n *\r\n * @see ClickEventListener\r\n * @see DragEventListener\r\n * @see ScrollEventListener\r\n * @see HoverEventListener\r\n */\r\nclass InteractionManager {\r\n\t/** Registry for click event listeners. */\r\n\tclick: PrioritizedEventHandlerRegistry<ClickEventListener> = new PrioritizedEventHandlerRegistry();\r\n\t/** Registry for drag event listeners. */\r\n\tdrag: PrioritizedEventHandlerRegistry<DragEventListener> = new PrioritizedEventHandlerRegistry();\r\n\t/** Registry for scroll event listeners. */\r\n\tscroll: PrioritizedEventHandlerRegistry<ScrollEventListener> = new PrioritizedEventHandlerRegistry();\r\n\t/** Registry for multi-touch event listeners. */\r\n\tmultitouch: PrioritizedEventHandlerRegistry<MultiTouchEventListener> = new PrioritizedEventHandlerRegistry();\r\n\t/** Registry for hover event listeners. */\r\n\thover: PrioritizedEventHandlerRegistry<HoverEventListener> = new PrioritizedEventHandlerRegistry();\r\n\tdragTimeout: NodeJS.Timeout | null = null;\r\n\tpressX: number = 0;\r\n\tpressY: number = 0;\r\n\ttouchPoints: Map<number, { x: number, y: number }> = new Map();\r\n\r\n\tconstructor() {\r\n\t\tdocument.addEventListener(\"pointerdown\", this.onPointerDown);\r\n\t\tdocument.addEventListener(\"pointerup\", this.onPointerUp);\r\n\t\tdocument.addEventListener(\"pointerout\", this.onPointerUp);\r\n\t\tdocument.addEventListener(\"pointerleave\", this.onPointerUp);\r\n\t\tdocument.addEventListener(\"pointercancel\", this.onPointerUp);\r\n\t\tdocument.addEventListener(\"pointermove\", this.onHover);\r\n\t\tdocument.addEventListener(\"wheel\", this.onScroll, {passive: false});\r\n\t}\r\n\r\n\tprivate onPointerDown(this: void, event: PointerEvent) {\r\n\t\tinteractionManager.touchPoints.set(event.pointerId, {x: event.x, y: event.y});\r\n\t\tif (interactionManager.touchPoints.size > 1) return;\r\n\t\tinteractionManager.pressX = event.x;\r\n\t\tinteractionManager.pressY = event.y;\r\n\t\tinteractionManager.dragTimeout = setTimeout(() => {\r\n\t\t\tinteractionManager.dragTimeout = null;\r\n\t\t\tinteractionManager.drag.choose(event.x, event.y);\r\n\t\t\tinteractionManager.drag.call(l => l.onDragStart(event.x, event.y));\r\n\t\t}, 1000);\r\n\t}\r\n\r\n\tprivate onPointerUp(this: void, event: PointerEvent) {\r\n\t\tinteractionManager.touchPoints.delete(event.pointerId);\r\n\t\tif (interactionManager.touchPoints.size > 0) {\r\n\t\t\tif (interactionManager.touchPoints.size === 1) {\r\n\t\t\t\tconst point = interactionManager.touchPoints.values().next().value as { x: number, y: number };\r\n\t\t\t\tinteractionManager.pressX = point.x;\r\n\t\t\t\tinteractionManager.pressY = point.y;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (interactionManager.dragTimeout) {\r\n\t\t\tclearTimeout(interactionManager.dragTimeout);\r\n\t\t\tinteractionManager.dragTimeout = null;\r\n\t\t\tinteractionManager.click.choose(event.x, event.y);\r\n\t\t\tinteractionManager.click.call(l => l.onClick(event.x, event.y));\r\n\t\t} else {\r\n\t\t\tinteractionManager.drag.call(l => l.onDragEnd(event.x, event.y));\r\n\t\t\tinteractionManager.drag.reset();\r\n\t\t}\r\n\t}\r\n\r\n\tprivate onHover(this: void, event: PointerEvent) {\r\n\t\tif (interactionManager.dragTimeout) {\r\n\t\t\tif (Math.abs(event.x - interactionManager.pressX) + Math.abs(event.y - interactionManager.pressY) < 10) return;\r\n\t\t\tclearTimeout(interactionManager.dragTimeout);\r\n\t\t\tinteractionManager.dragTimeout = null;\r\n\t\t\tinteractionManager.drag.choose(interactionManager.pressX, interactionManager.pressY);\r\n\t\t\tinteractionManager.drag.call(l => l.onDragStart(interactionManager.pressX, interactionManager.pressY));\r\n\t\t}\r\n\t\tif (interactionManager.touchPoints.size > 1) {\r\n\t\t\tinteractionManager.checkMobileGesture(event);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinteractionManager.drag.call(l => l.onDragMove(event.x, event.y, event.x - interactionManager.pressX, event.y - interactionManager.pressY));\r\n\t\tinteractionManager.pressX = event.x;\r\n\t\tinteractionManager.pressY = event.y;\r\n\t\tinteractionManager.hover.choose(event.x, event.y);\r\n\t\tinteractionManager.hover.call(l => l.onHover(event.x, event.y));\r\n\t}\r\n\r\n\tprivate onScroll(this: void, event: WheelEvent) {\r\n\t\tlet delta = event.deltaY;\r\n\t\tif (event.ctrlKey) {\r\n\t\t\tevent.preventDefault();\r\n\t\t\tdelta *= 7;\r\n\t\t}\r\n\t\tinteractionManager.scroll.choose(event.x, event.y);\r\n\t\tinteractionManager.scroll.call(l => l.onScroll(event.x, event.y, delta));\r\n\t}\r\n\r\n\tprivate checkMobileGesture(this: void, event: PointerEvent) {\r\n\t\tif (interactionManager.touchPoints.size !== 2) return;\r\n\t\tconst [oldPoint1, oldPoint2] = Array.from(interactionManager.touchPoints.values());\r\n\t\tinteractionManager.touchPoints.set(event.pointerId, {x: event.x, y: event.y});\r\n\t\tconst [newPoint1, newPoint2] = Array.from(interactionManager.touchPoints.values());\r\n\r\n\t\tconst oldDistance = Math.hypot(oldPoint1.x - oldPoint2.x, oldPoint1.y - oldPoint2.y);\r\n\t\tconst newDistance = Math.hypot(newPoint1.x - newPoint2.x, newPoint1.y - newPoint2.y);\r\n\t\tconst zoomFactor = newDistance / oldDistance;\r\n\t\tconst oldCenterX = (oldPoint1.x + oldPoint2.x) / 2, oldCenterY = (oldPoint1.y + oldPoint2.y) / 2;\r\n\t\tconst newCenterX = (newPoint1.x + newPoint2.x) / 2, newCenterY = (newPoint1.y + newPoint2.y) / 2;\r\n\r\n\t\tinteractionManager.multitouch.choose(newCenterX, newCenterY);\r\n\t\tinteractionManager.multitouch.call(l => l.onMultiTouch(oldCenterX, oldCenterY, newCenterX, newCenterY, zoomFactor));\r\n\t}\r\n}\r\n\r\n/**\r\n * Listener for basic interactions.\r\n * This interface is not meant to be implemented directly.\r\n * Refer to the specific event listener interfaces instead.\r\n */\r\nexport interface BasicInteractionListener {\r\n\t/**\r\n\t * Tests if the listener should receive events at the given position.\r\n\t * @param x The screen x-coordinate of the event.\r\n\t * @param y The screen y-coordinate of the event.\r\n\t * @returns True if the listener should receive events at the given position.\r\n\t */\r\n\ttest(x: number, y: number): boolean;\r\n}\r\n\r\n/**\r\n * Listener for click events.\r\n *\r\n * Register a listener with the click registry to receive click events.\r\n * @see InteractionManager.click\r\n * @see PrioritizedEventHandlerRegistry.register\r\n */\r\nexport interface ClickEventListener extends BasicInteractionListener {\r\n\t/**\r\n\t * Called when the user clicks at the given position.\r\n\t * @param x The screen x-coordinate of the click.\r\n\t * @param y The screen y-coordinate of the click.\r\n\t */\r\n\tonClick(x: number, y: number): void;\r\n}\r\n\r\n/**\r\n * Listener for drag events.\r\n *\r\n * Register a listener with the drag registry to receive drag events.\r\n * @see InteractionManager.drag\r\n * @see PrioritizedEventHandlerRegistry.register\r\n */\r\nexport interface DragEventListener extends BasicInteractionListener {\r\n\t/**\r\n\t * Called when the user starts dragging at the given position.\r\n\t * @param x The screen x-coordinate of the drag start.\r\n\t * @param y The screen y-coordinate of the drag start.\r\n\t */\r\n\tonDragStart(x: number, y: number): void;\r\n\r\n\t/**\r\n\t * Called when the user drags to the given position.\r\n\t * @param x The screen x-coordinate of the drag move.\r\n\t * @param y The screen y-coordinate of the drag move.\r\n\t * @param dx The x-delta of the drag.\r\n\t * @param dy The y-delta of the drag.\r\n\t */\r\n\tonDragMove(x: number, y: number, dx: number, dy: number): void;\r\n\r\n\t/**\r\n\t * Called when the user stops dragging at the given position.\r\n\t * @param x The screen x-coordinate of the drag end.\r\n\t * @param y The screen y-coordinate of the drag end.\r\n\t */\r\n\tonDragEnd(x: number, y: number): void;\r\n}\r\n\r\n/**\r\n * Listener for scroll events.\r\n *\r\n * Register a listener with the scroll registry to receive scroll events.\r\n * @see InteractionManager.scroll\r\n * @see PrioritizedEventHandlerRegistry.register\r\n */\r\nexport interface ScrollEventListener extends BasicInteractionListener {\r\n\t/**\r\n\t * Called when the user scrolls at the given position.\r\n\t * @param x The screen x-coordinate of the scroll.\r\n\t * @param y The screen y-coordinate of the scroll.\r\n\t * @param delta The scroll delta.\r\n\t */\r\n\tonScroll(x: number, y: number, delta: number): void;\r\n}\r\n\r\n/**\r\n * Listener for multi-touch events.\r\n *\r\n * Register a listener with the pinch registry to receive pinch events.\r\n * @see InteractionManager.pinch\r\n * @see PrioritizedEventHandlerRegistry.register\r\n */\r\nexport interface MultiTouchEventListener extends BasicInteractionListener {\r\n\t/**\r\n\t * Called when the user interacts with multiple touch points.\r\n\t * @param oldX The centered screen x-coordinate of the old touch points.\r\n\t * @param oldY The centered screen y-coordinate of the old touch points.\r\n\t * @param newX The centered screen x-coordinate of the new touch points.\r\n\t * @param newY The centered screen y-coordinate of the new touch points.\r\n\t * @param factor The zoom factor.\r\n\t */\r\n\tonMultiTouch(oldX: number, oldY: number, newX: number, newY: number, factor: number): void;\r\n}\r\n\r\n/**\r\n * Listener for hover events.\r\n *\r\n * Register a listener with the hover registry to receive hover events.\r\n * @see InteractionManager.hover\r\n * @see PrioritizedEventHandlerRegistry.register\r\n */\r\nexport interface HoverEventListener extends BasicInteractionListener {\r\n\t/**\r\n\t * Called when the user hovers at the given position.\r\n\t * @param x The screen x-coordinate of the hover.\r\n\t * @param y The screen y-coordinate of the hover.\r\n\t */\r\n\tonHover(x: number, y: number): void;\r\n}\r\n\r\nexport const interactionManager = new InteractionManager();","import {EventHandlerRegistry} from \"./EventHandlerRegistry\";\r\nimport {mapNavigationHandler} from \"../game/action/MapNavigationHandler\";\r\n\r\n/**\r\n * Registry for map transform listeners.\r\n */\r\nclass MapTransformHandler {\r\n\t/**\r\n\t * Registry for map scale listeners.\r\n\t * Map scale listeners are called when the map scale changes.\r\n\t *\r\n\t * Format: (scale: number) => void\r\n\t * @param scale The new scale of the map.\r\n\t */\r\n\tscale: EventHandlerRegistry<[number]> = new EventHandlerRegistry(true, listener => listener(mapNavigationHandler.zoom));\r\n\t/**\r\n\t * Registry for map move listeners.\r\n\t * Map move listeners are called when the map is moved.\r\n\t *\r\n\t * Format: (x: number, y: number) => void\r\n\t * @param x The new x-coordinate of the map.\r\n\t * @param y The new y-coordinate of the map.\r\n\t */\r\n\tmove: EventHandlerRegistry<[number, number]> = new EventHandlerRegistry(true, listener => listener(mapNavigationHandler.x, mapNavigationHandler.y));\r\n}\r\n\r\nexport const mapTransformHandler = new MapTransformHandler();","import {\r\n\tDragEventListener,\r\n\tinteractionManager,\r\n\tMultiTouchEventListener,\r\n\tScrollEventListener\r\n} from \"../../event/InteractionManager\";\r\nimport {gameMap} from \"../Game\";\r\nimport {mapTransformHandler} from \"../../event/MapTransformHandler\";\r\n\r\n/**\r\n * Default map navigation handler.\r\n * Controls the map position and zoom level.\r\n * @see MapTransformHandler\r\n */\r\nclass MapNavigationHandler implements ScrollEventListener, DragEventListener, MultiTouchEventListener {\r\n\tx: number = 0;\r\n\ty: number = 0;\r\n\tzoom: number = 1;\r\n\r\n\t/**\r\n\t * Enables the map navigation handler.\r\n\t * Sets the initial zoom level and position to center the map on the screen.\r\n\t */\r\n\tenable() {\r\n\t\tconst minXZoom = window.innerWidth / gameMap.width, minYZoom = window.innerHeight / gameMap.height;\r\n\t\tthis.zoom = 0.9 * Math.min(minXZoom, minYZoom);\r\n\t\tthis.x = (window.innerWidth - gameMap.width * this.zoom) / 2;\r\n\t\tthis.y = (window.innerHeight - gameMap.height * this.zoom) / 2;\r\n\t\tmapTransformHandler.scale.broadcast();\r\n\t\tmapTransformHandler.move.broadcast();\r\n\t\tinteractionManager.drag.register(this);\r\n\t\tinteractionManager.scroll.register(this);\r\n\t\tinteractionManager.multitouch.register(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Disables the map navigation handler.\r\n\t */\r\n\tdisable() {\r\n\t\tinteractionManager.drag.unregister(this);\r\n\t\tinteractionManager.scroll.unregister(this);\r\n\t\tinteractionManager.multitouch.unregister(this);\r\n\t}\r\n\r\n\tonScroll(x: number, y: number, delta: number): void {\r\n\t\tif (delta > 0) {\r\n\t\t\tthis.processZoom(x, y, this.zoom / (1 + delta / 600));\r\n\t\t} else {\r\n\t\t\tthis.processZoom(x, y, this.zoom * (1 - delta / 600));\r\n\t\t}\r\n\t}\r\n\r\n\tprivate processZoom(x: number, y: number, newZoom: number) {\r\n\t\tif (newZoom < 0.1 || newZoom > 200) return;\r\n\t\tconst mapX = this.getMapX(x), mapY = this.getMapY(y);\r\n\t\tthis.zoom = newZoom;\r\n\t\tthis.x = Math.max(Math.min(-mapX * this.zoom + x, window.innerWidth - 100), 100 - gameMap.width * this.zoom);\r\n\t\tthis.y = Math.max(Math.min(-mapY * this.zoom + y, window.innerHeight - 100), 100 - gameMap.height * this.zoom);\r\n\t\tmapTransformHandler.scale.broadcast();\r\n\t\tmapTransformHandler.move.broadcast();\r\n\t}\r\n\r\n\tonMultiTouch(oldX: number, oldY: number, newX: number, newY: number, factor: number) {\r\n\t\tfactor = Math.max(0.1, Math.min(200, factor * this.zoom)) / this.zoom;\r\n\t\tthis.x = Math.max(Math.min(newX - (oldX - this.x) * factor, window.innerWidth - 100), 100 - gameMap.width * this.zoom);\r\n\t\tthis.y = Math.max(Math.min(newY - (oldY - this.y) * factor, window.innerHeight - 100), 100 - gameMap.height * this.zoom);\r\n\t\tthis.zoom *= factor;\r\n\t\tmapTransformHandler.scale.broadcast();\r\n\t\tmapTransformHandler.move.broadcast();\r\n\t}\r\n\r\n\ttest(_x: number, _y: number): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tonDragStart(_x: number, _y: number): void {\r\n\t}\r\n\r\n\tonDragEnd(_x: number, _y: number): void {\r\n\t}\r\n\r\n\tonDragMove(_x: number, _y: number, dx: number, dy: number): void {\r\n\t\tthis.x = Math.max(Math.min(this.x + dx, window.innerWidth - 100), 100 - gameMap.width * this.zoom);\r\n\t\tthis.y = Math.max(Math.min(this.y + dy, window.innerHeight - 100), 100 - gameMap.height * this.zoom);\r\n\t\tmapTransformHandler.move.broadcast();\r\n\t}\r\n\r\n\t/**\r\n\t * Converts screen coordinates to map coordinates.\r\n\t * @param x The x-coordinate on the screen.\r\n\t */\r\n\tgetMapX(x: number): number {\r\n\t\treturn (x - this.x) / this.zoom;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts screen coordinates to map coordinates.\r\n\t * @param y The y-coordinate on the screen.\r\n\t */\r\n\tgetMapY(y: number): number {\r\n\t\treturn (y - this.y) / this.zoom;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the given screen coordinates are on the map.\r\n\t * Not to be confused with map coordinates (This method does not convert screen coordinates to map coordinates).\r\n\t * @param x The x-coordinate on the screen.\r\n\t * @param y The y-coordinate on the screen.\r\n\t */\r\n\tisOnMap(x: number, y: number): boolean {\r\n\t\treturn x >= this.x && x < this.x + gameMap.width * this.zoom && y >= this.y && y < this.y + gameMap.height * this.zoom;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts screen coordinates to a map tile index.\r\n\t * @param x The x-coordinate on the screen.\r\n\t * @param y The y-coordinate on the screen.\r\n\t */\r\n\tgetIndex(x: number, y: number): number {\r\n\t\treturn Math.floor((y - this.y) / this.zoom) * gameMap.width + Math.floor((x - this.x) / this.zoom);\r\n\t}\r\n}\r\n\r\nexport const mapNavigationHandler = new MapNavigationHandler();","import {gameMap} from \"../game/Game\";\r\nimport {territoryManager} from \"../game/TerritoryManager\";\r\n\r\n/**\r\n * Call a closure on all neighbors of a tile.\r\n * @param tile The tile to get the neighbors of.\r\n * @param closure The closure to call on each neighbor.\r\n */\r\nexport function onNeighbors(tile: number, closure: (tile: number) => void): void {\r\n\tconst x = tile % gameMap.width;\r\n\tconst y = Math.floor(tile / gameMap.width);\r\n\tif (x > 0) {\r\n\t\tclosure(tile - 1);\r\n\t}\r\n\tif (x < gameMap.width - 1) {\r\n\t\tclosure(tile + 1);\r\n\t}\r\n\tif (y > 0) {\r\n\t\tclosure(tile - gameMap.width);\r\n\t}\r\n\tif (y < gameMap.height - 1) {\r\n\t\tclosure(tile + gameMap.width);\r\n\t}\r\n}\r\n\r\n/**\r\n * Check if a tile borders a tile owned by a player.\r\n * @param tile The tile to check.\r\n * @param player The player to check for.\r\n * @returns True if the tile borders a tile owned by the player, false otherwise.\r\n */\r\nexport function bordersTile(tile: number, player: number): boolean {\r\n\tconst x = tile % gameMap.width;\r\n\tconst y = Math.floor(tile / gameMap.width);\r\n\treturn (x > 0 && territoryManager.isOwner(tile - 1, player)) ||\r\n\t\t(x < gameMap.width - 1 && territoryManager.isOwner(tile + 1, player)) ||\r\n\t\t(y > 0 && territoryManager.isOwner(tile - gameMap.width, player)) ||\r\n\t\t(y < gameMap.height - 1 && territoryManager.isOwner(tile + gameMap.width, player));\r\n}","/**\r\n * Priority queue implementation using a binary heap.\r\n */\r\nexport class PriorityQueue<T> {\r\n\tprivate readonly heap: T[] = [];\r\n\r\n\t/**\r\n\t * Create a new priority queue.\r\n\t * @param comparator Comparator function to compare the priority of two values.\r\n\t */\r\n\tconstructor(private readonly comparator: (a: T, b: T) => boolean) {\r\n\t}\r\n\r\n\t/**\r\n\t * Check if the queue is empty.\r\n\t * @returns Whether the queue is empty.\r\n\t */\r\n\tisEmpty(): boolean {\r\n\t\treturn this.size() === 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the size of the queue.\r\n\t * @returns The size of the queue.\r\n\t */\r\n\tsize(): number {\r\n\t\treturn this.heap.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the value at the front of the queue.\r\n\t * @returns The value at the front of the queue.\r\n\t */\r\n\tpeek(): T {\r\n\t\treturn this.heap[0];\r\n\t}\r\n\r\n\t/**\r\n\t * Push a value into the queue.\r\n\t * @param value The value to push.\r\n\t * @returns The new size of the queue.\r\n\t */\r\n\tpush(value: T): number {\r\n\t\tthis.siftUp(value);\r\n\t\treturn this.size();\r\n\t}\r\n\r\n\t/**\r\n\t * Pop the value at the front of the queue.\r\n\t * @returns The value at the front of the queue.\r\n\t */\r\n\tpop(): T {\r\n\t\tif (this.size() === 1) {\r\n\t\t\treturn this.heap.pop() as T;\r\n\t\t}\r\n\r\n\t\tconst value = this.heap[0];\r\n\t\tthis.siftDown(this.heap.pop() as T);\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Update a value in the queue.\r\n\t * WARNING: The new value must have a higher priority than the old value.\r\n\t * @param predicate The predicate to find the value to update.\r\n\t * @param value The new value.\r\n\t * @returns The new size of the queue.\r\n\t */\r\n\tupdate(predicate: (element: T) => boolean, value: T): number {\r\n\t\tconst index = this.heap.findIndex(predicate);\r\n\t\tif (index === -1) {\r\n\t\t\treturn this.size();\r\n\t\t}\r\n\r\n\t\tthis.heap[index] = value;\r\n\t\tthis.siftUp(value, index);\r\n\t\treturn this.size();\r\n\t}\r\n\r\n\t/**\r\n\t * Sift up a node in the heap.\r\n\t * @param node The node to sift up.\r\n\t * @param index The index of the node in the heap.\r\n\t * @private\r\n\t */\r\n\tprivate siftUp(node: T, index: number = this.size()) {\r\n\t\twhile (index > 0) {\r\n\t\t\tconst parentIndex = ((index + 1) >>> 1) - 1;\r\n\t\t\tif (!this.comparator(node, this.heap[parentIndex])) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tthis.heap[index] = this.heap[parentIndex];\r\n\t\t\tindex = parentIndex;\r\n\t\t}\r\n\t\tthis.heap[index] = node;\r\n\t}\r\n\r\n\t/**\r\n\t * Sift down a node in the heap.\r\n\t * @param node The node to sift down.\r\n\t * @private\r\n\t */\r\n\tprivate siftDown(node: T) {\r\n\t\tlet index = 0;\r\n\t\tconst maxParent = this.size() >>> 1;\r\n\t\twhile (index < maxParent) {\r\n\t\t\tconst leftIndex = (index << 1) + 1;\r\n\t\t\tconst rightIndex = leftIndex + 1;\r\n\r\n\t\t\tconst leftValue = this.heap[leftIndex];\r\n\t\t\tconst rightValue = this.heap[rightIndex];\r\n\t\t\tif (rightIndex < this.size() && this.comparator(rightValue, leftValue)) {\r\n\t\t\t\tif (this.comparator(rightValue, node)) {\r\n\t\t\t\t\tthis.heap[index] = rightValue;\r\n\t\t\t\t\tindex = rightIndex;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (this.comparator(leftValue, node)) {\r\n\t\t\t\t\tthis.heap[index] = leftValue;\r\n\t\t\t\t\tindex = leftIndex;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.heap[index] = node;\r\n\t}\r\n}","/**\r\n * A simple pseudo-random number generator.\r\n * This uses the SplitMix32 algorithm to generate random 32-bit integers.\r\n *\r\n * ONLY USE THIS FOR DETERMINISTIC RANDOMNESS OF GAMEPLAY ELEMENTS.\r\n * NEVER USE THIS FOR CLIENT-SIDE LOGIC OR RENDERING.\r\n */\r\nclass Random {\r\n\tseed: number;\r\n\r\n\t/**\r\n\t * Creates a new Random instance with a random seed.\r\n\t * @param seed seed for the random number generator\r\n\t * @internal\r\n\t */\r\n\treset(seed: number): void {\r\n\t\tthis.seed = seed;\r\n\t}\r\n\r\n\t/**\r\n\t * Generate a random number and advances the internal state.\r\n\t * @see Random\r\n\t * @returns a random number between 0 and 1\r\n\t */\r\n\tnext(): number {\r\n\t\tthis.seed |= 0;\r\n\t\tthis.seed = this.seed + 0x9e3779b9 | 0;\r\n\t\tlet t = this.seed ^ this.seed >>> 16;\r\n\t\tt = Math.imul(t, 0x21f0aaad);\r\n\t\tt = t ^ t >>> 15;\r\n\t\tt = Math.imul(t, 0x735a2d97);\r\n\t\treturn ((t ^ t >>> 15) >>> 0) / 4294967296;\r\n\t}\r\n\r\n\t/**\r\n\t * Generate a random integer between 0 and max.\r\n\t * @param max the maximum value (exclusive)\r\n\t * @returns a random integer between 0 and max\r\n\t */\r\n\tnextInt(max: number): number {\r\n\t\treturn Math.floor(this.next() * max);\r\n\t}\r\n}\r\n\r\nexport const random = new Random();","import {Player} from \"../../game/player/Player\";\r\nimport {gameMap} from \"../../game/Game\";\r\nimport {formatTroops} from \"../../util/StringFormatter\";\r\nimport {PriorityQueue} from \"../../util/PriorityQueue\";\r\nimport {territoryManager} from \"../../game/TerritoryManager\";\r\nimport {getSetting} from \"../../util/UserSettingManager\";\r\nimport {random} from \"../../game/Random\";\r\nimport {gameTicker} from \"../../game/GameTicker\";\r\nimport {mapNavigationHandler} from \"../../game/action/MapNavigationHandler\";\r\n\r\nclass PlayerNameRenderingManager {\r\n\tplayerData: PlayerNameRenderingData[] = [];\r\n\tprivate nameDepth: Uint16Array;\r\n\tatlasRowLength: number = 0;\r\n\treadonly partialElementAtlas: HTMLCanvasElement = document.createElement(\"canvas\")\r\n\tpartialAtlasContext: CanvasRenderingContext2D;\r\n\r\n\t/**\r\n\t * Data for the current transaction.\r\n\t * TODO: Move this somewhere else, maybe a proper transaction implementation...\r\n\t */\r\n\tprivate currentPlayerMax: number = 0;\r\n\tprivate currentPlayerPos: number = 0;\r\n\tprivate currentTargetMax: number = 0;\r\n\tprivate currentTargetPos: number = 0;\r\n\r\n\treset(maxPlayers: number) {\r\n\t\tthis.playerData = [];\r\n\t\tthis.nameDepth = new Uint16Array(gameMap.width * gameMap.height);\r\n\t\tthis.atlasRowLength = Math.sqrt(maxPlayers) | 0;\r\n\t\tthis.partialElementAtlas.width = this.atlasRowLength * 20;\r\n\t\tthis.partialElementAtlas.height = Math.ceil(maxPlayers / this.atlasRowLength) * 20;\r\n\t\tthis.partialAtlasContext = this.partialElementAtlas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\t\tthis.partialAtlasContext.textRendering = \"optimizeSpeed\";\r\n\t\tthis.partialAtlasContext.textAlign = \"center\";\r\n\t\tthis.partialAtlasContext.textBaseline = \"bottom\";\r\n\t}\r\n\r\n\t/**\r\n\t * Register a player for name rendering.\r\n\t * @param player The player to register.\r\n\t */\r\n\tregisterPlayer(player: Player): void {\r\n\t\tconst canvas = document.createElement(\"canvas\");\r\n\t\tconst context = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\t\tconst troopLength = context.measureText(\"123.\").width / 10;\r\n\t\tthis.playerData[player.id] = new PlayerNameRenderingData(player.name, troopLength, player.borderTiles, player.id);\r\n\t}\r\n\r\n\t//TODO: Remove this hacky solution, just pass the player instance to the rendering manager\r\n\t/**\r\n\t * Finish the registration process.\r\n\t * @param players The players to finish the registration for.\r\n\t */\r\n\tfinishRegistration(players: Player[]): void {\r\n\t\tplayerNameRenderingManager.partialAtlasContext.textBaseline = \"top\";\r\n\t\tfor (const player of players) {\r\n\t\t\tthis.playerData[player.id].updatePartial(player);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Check if a tile is considered for name rendering.\r\n\t * @param tile The tile to check.\r\n\t * @returns True if the tile is considered, false otherwise.\r\n\t * @internal Use {@link TerritoryManager.isTerritory} instead.\r\n\t */\r\n\tisConsidered(tile: number): boolean {\r\n\t\treturn this.nameDepth[tile] > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Update the player name rendering data.\r\n\t * @internal\r\n\t */\r\n\taddTile(tile: number): void {\r\n\t\tthis.nameDepth[tile] = 65535; // force recalculation\r\n\t\tthis.recalculateFrom(tile);\r\n\t}\r\n\r\n\t/**\r\n\t * Update the player name rendering data.\r\n\t * @internal\r\n\t */\r\n\tremoveTile(tile: number): void {\r\n\t\tlet offset = 0;\r\n\t\tlet rowMax = Infinity;\r\n\t\tlet columnMax = Infinity;\r\n\t\tif (this.currentTargetMax < this.nameDepth[tile - gameMap.width - 1]) {\r\n\t\t\tthis.currentTargetMax = this.nameDepth[tile - gameMap.width - 1];\r\n\t\t\tthis.currentTargetPos = tile - gameMap.width - 1;\r\n\t\t}\r\n\t\tlet changed: boolean;\r\n\t\tdo {\r\n\t\t\tchanged = false;\r\n\t\t\tfor (let i = 0; i < rowMax; i++) {\r\n\t\t\t\tif (this.nameDepth[tile + i] <= offset + i) {\r\n\t\t\t\t\trowMax = i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tthis.nameDepth[tile + i] = offset + i;\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\ttile += gameMap.width;\r\n\t\t\tfor (let i = 0; i < columnMax; i++) {\r\n\t\t\t\tif (this.nameDepth[tile + i * gameMap.width] <= offset + i) {\r\n\t\t\t\t\tcolumnMax = i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tthis.nameDepth[tile + i * gameMap.width] = offset + i;\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\ttile++;\r\n\t\t\toffset++;\r\n\t\t} while (changed);\r\n\t}\r\n\r\n\t/**\r\n\t * Execute the transaction.\r\n\t * @param player the player to apply the transaction to\r\n\t * @param target the target player\r\n\t * @internal\r\n\t */\r\n\tapplyTransaction(player: Player, target: Player): void {\r\n\t\tif (this.currentPlayerMax !== 0) this.playerData[player.id].handleAdd(this.currentPlayerMax, this.currentPlayerPos);\r\n\t\tif (this.currentTargetMax !== 0) this.playerData[target.id].handleRemove(this.nameDepth, this.currentTargetMax, this.currentTargetPos);\r\n\t\tthis.currentPlayerMax = 0;\r\n\t\tthis.currentPlayerPos = 0;\r\n\t\tthis.currentTargetMax = 0;\r\n\t\tthis.currentTargetPos = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Recalculate the name depth map from a specific tile.\r\n\t * Name depth refers to the maximum size a square can be with the bottom-right corner at the tile.\r\n\t * @param tile The tile to recalculate from.\r\n\t * @private\r\n\t */\r\n\tprivate recalculateFrom(tile: number): void {\r\n\t\tlet currentOrigin = tile;\r\n\t\tlet isColumn = false;\r\n\t\tlet changed = true;\r\n\t\tlet max = 0;\r\n\t\tlet maxPos = 0;\r\n\r\n\t\tlet currentMax = Infinity;\r\n\t\tlet otherMax = Infinity;\r\n\t\twhile (true) {\r\n\t\t\tlet current = currentOrigin;\r\n\t\t\tfor (let i = 0; i < currentMax; i++) {\r\n\t\t\t\tif (!this.nameDepth[current]) { // Border / unclaimed tile\r\n\t\t\t\t\tcurrentMax = i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tconst value = Math.min(this.nameDepth[current - 1], this.nameDepth[current - gameMap.width], this.nameDepth[current - gameMap.width - 1]) + 1;\r\n\t\t\t\tif (value === this.nameDepth[current]) {\r\n\t\t\t\t\tcurrentMax = i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (value > max) {\r\n\t\t\t\t\tmax = value;\r\n\t\t\t\t\tmaxPos = current;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tchanged = true;\r\n\t\t\t\tthis.nameDepth[current] = value;\r\n\r\n\t\t\t\tcurrent += isColumn ? gameMap.width : 1;\r\n\t\t\t}\r\n\t\t\tif (isColumn) {\r\n\t\t\t\tif (!changed) break;\r\n\t\t\t\tchanged = false;\r\n\t\t\t\tcurrentOrigin++;\r\n\t\t\t\tisColumn = false;\r\n\t\t\t} else {\r\n\t\t\t\tisColumn = true;\r\n\t\t\t\tcurrentOrigin += gameMap.width;\r\n\t\t\t}\r\n\t\t\t[currentMax, otherMax] = [otherMax, currentMax];\r\n\t\t}\r\n\r\n\t\tif (max > this.currentPlayerMax) {\r\n\t\t\tthis.currentPlayerMax = max;\r\n\t\t\tthis.currentPlayerPos = maxPos;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//TODO: Remove this\r\nexport class PlayerNameRenderingData {\r\n\tprivate readonly id: number;\r\n\treadonly updateTick: number = 0;\r\n\tsize: number = 0;\r\n\tindex: number = 0;\r\n\tnameX: number = 0;\r\n\tnameY: number = 0;\r\n\tprivate nameLength: number;\r\n\tprivate readonly troopLength: number;\r\n\ttroopSize: number = 0;\r\n\tprivate readonly borderSet: Set<number>;\r\n\treadonly queue: PriorityQueue<[number, number]> = new PriorityQueue((a, b) => a[0] > b[0]);\r\n\r\n\tconstructor(name: string, troopLength: number, borderSet: Set<number>, id: number) {\r\n\t\tthis.troopLength = troopLength;\r\n\t\tthis.borderSet = borderSet;\r\n\t\tthis.id = id;\r\n\t\tthis.updateTick = random.nextInt(10);\r\n\t\tthis.renderName(name);\r\n\t}\r\n\r\n\t/**\r\n\t * Render the player name.\r\n\t * @param name The name of the player.\r\n\t * @private\r\n\t */\r\n\tprivate renderName(name: string): void {\r\n\t\tplayerNameRenderingManager.partialAtlasContext.fillStyle = \"rgb(0, 0, 0)\"; //TODO: This needs to be decided by the theme\r\n\t\tplayerNameRenderingManager.partialAtlasContext.font = \"bold \" + Math.min(Math.floor(200 / (this.nameLength = playerNameRenderingManager.partialAtlasContext.measureText(name).width)), 8) + \"px \" + getSetting(\"theme\").getFont();\r\n\t\tplayerNameRenderingManager.partialAtlasContext.fillText(name, this.id % playerNameRenderingManager.atlasRowLength * 20 + 10, Math.floor(this.id / playerNameRenderingManager.atlasRowLength) * 20 + 10);\r\n\t}\r\n\r\n\t/**\r\n\t * Add a tile to the queue or adjust the current position if applicable.\r\n\t * @param max the maximum size of the square\r\n\t * @param pos the position of the square\r\n\t */\r\n\thandleAdd(max: number, pos: number): void {\r\n\t\tif (this.size < max) {\r\n\t\t\tthis.queue.push([this.size, this.index]);\r\n\t\t\tthis.setPosAt(pos, max);\r\n\t\t} else {\r\n\t\t\tthis.queue.push([max, pos]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Remove a tile from the queue or adjust the current position if applicable.\r\n\t * @param nameDepth the name depth map\r\n\t * @param max the maximum size of the square\r\n\t * @param pos the position of the square\r\n\t */\r\n\thandleRemove(nameDepth: Uint16Array, max: number, pos: number): void {\r\n\t\tthis.handleAdd(max, pos);\r\n\t\tif (nameDepth[this.index] === this.size) return;\r\n\t\tthis.queue.push([nameDepth[this.index], this.index]);\r\n\t\twhile (!this.queue.isEmpty()) {\r\n\t\t\tconst [newMax, newPos] = this.queue.pop();\r\n\t\t\tif (territoryManager.tileOwners[newPos] === this.id) {\r\n\t\t\t\tconst size = nameDepth[newPos];\r\n\t\t\t\tif (size >= newMax) {\r\n\t\t\t\t\tthis.setPosAt(newPos, size);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.setPosAt(this.borderSet.values().next().value as number, 1);\r\n\t}\r\n\r\n\tsetPosAt(tile: number, size: number): void {\r\n\t\tthis.size = size;\r\n\t\tthis.index = tile;\r\n\t\tthis.nameX = tile % gameMap.width;\r\n\t\tthis.nameY = Math.floor(tile / gameMap.width);\r\n\t}\r\n\r\n\t/**\r\n\t * Render the player name.\r\n\t * If the name is small, use the cached partial, otherwise render the name directly.\r\n\t * @param context The context to render the name to.\r\n\t * @param player The player to render the name for.\r\n\t */\r\n\trenderPlayer(context: CanvasRenderingContext2D, player: Player): void {\r\n\t\tif (gameTicker.getTickCount() % 10 === this.updateTick) this.updatePartial(player);\r\n\t\tif (this.size * mapNavigationHandler.zoom >= 20) {\r\n\t\t\tcontext.fillStyle = \"rgb(0, 0, 0)\"; //TODO: This needs to be decided by the theme\r\n\t\t\tcontext.textBaseline = \"bottom\";\r\n\t\t\tcontext.font = \"bold \" + Math.floor(Math.min(10 / this.nameLength, 0.4) * this.size * mapNavigationHandler.zoom) + \"px \" + getSetting(\"theme\").getFont();\r\n\t\t\tcontext.fillText(player.name, Math.floor((this.nameX - this.size / 2 + 1) * mapNavigationHandler.zoom + mapNavigationHandler.x), Math.floor((this.nameY - this.size / 2 + 1) * mapNavigationHandler.zoom + mapNavigationHandler.y));\r\n\t\t\tcontext.textBaseline = \"top\";\r\n\t\t\tcontext.font = \"bold \" + Math.floor(1 / Math.max(3, player.getTroops().toString().length) * 3 * this.size / this.troopLength * mapNavigationHandler.zoom) + \"px \" + getSetting(\"theme\").getFont();\r\n\t\t\tcontext.fillText(formatTroops(player.getTroops()), Math.floor((this.nameX - this.size / 2 + 1) * mapNavigationHandler.zoom + mapNavigationHandler.x), Math.floor((this.nameY - this.size / 2 + 1) * mapNavigationHandler.zoom + mapNavigationHandler.y));\r\n\t\t} else {\r\n\t\t\tcontext.drawImage(playerNameRenderingManager.partialElementAtlas, (this.id % playerNameRenderingManager.atlasRowLength) * 20, Math.floor(this.id / playerNameRenderingManager.atlasRowLength) * 20, 20, 20, Math.floor((this.nameX - this.size + 1) * mapNavigationHandler.zoom + mapNavigationHandler.x), Math.floor((this.nameY - this.size + 1) * mapNavigationHandler.zoom + mapNavigationHandler.y), Math.floor(this.size * mapNavigationHandler.zoom), Math.floor(this.size * mapNavigationHandler.zoom));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Update the partial canvas.\r\n\t * @param player The player to update the partial for.\r\n\t */\r\n\tupdatePartial(player: Player): void {\r\n\t\tplayerNameRenderingManager.partialAtlasContext.clearRect(this.id % playerNameRenderingManager.atlasRowLength * 20, Math.floor(this.id / playerNameRenderingManager.atlasRowLength) * 20 + 10, 20, 10);\r\n\t\tplayerNameRenderingManager.partialAtlasContext.fillStyle = \"rgb(0, 0, 0)\"; //TODO: This needs to be decided by the theme\r\n\t\tplayerNameRenderingManager.partialAtlasContext.font = \"bold \" + Math.floor(60 / Math.max(3, player.getTroops().toString().length) / this.troopLength) + \"px \" + getSetting(\"theme\").getFont();\r\n\t\tplayerNameRenderingManager.partialAtlasContext.fillText(formatTroops(player.getTroops()), this.id % playerNameRenderingManager.atlasRowLength * 20 + 10, Math.floor(this.id / playerNameRenderingManager.atlasRowLength) * 20 + 10);\r\n\t}\r\n}\r\n\r\nexport const playerNameRenderingManager = new PlayerNameRenderingManager();","import {RendererLayer} from \"./RendererLayer\";\r\n\r\n/**\r\n * Caches rendered layer in a separate canvas.\r\n *\r\n * Useful for layers that are expensive to render and don't change very often.\r\n * Allows for faster rendering by only rendering the layer once and then reusing the cached image.\r\n * Can be scaled and moved like any other layer (you might need to listen to map events to update the position).\r\n */\r\nexport abstract class CachedLayer implements RendererLayer {\r\n\tcanvas: HTMLCanvasElement;\r\n\tcontext: CanvasRenderingContext2D;\r\n\tdx: number = 0;\r\n\tdy: number = 0;\r\n\tscale: number = 1;\r\n\r\n\tpublic constructor() {\r\n\t\tthis.canvas = document.createElement(\"canvas\");\r\n\t\tthis.context = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\t}\r\n\r\n\t/**\r\n\t * Resize the canvas to the given width and height.\r\n\t * @param width width of the canvas\r\n\t * @param height height of the canvas\r\n\t * @protected\r\n\t */\r\n\tprotected resizeCanvas(width: number, height: number) {\r\n\t\tthis.canvas.width = width;\r\n\t\tthis.canvas.height = height;\r\n\t}\r\n\r\n\trender(context: CanvasRenderingContext2D): void {\r\n\t\tcontext.drawImage(this.canvas, this.dx, this.dy, this.canvas.width * this.scale, this.canvas.height * this.scale);\r\n\t}\r\n}","import {CachedLayer} from \"./CachedLayer\";\r\nimport {gameMap} from \"../../game/Game\";\r\nimport {mapTransformHandler} from \"../../event/MapTransformHandler\";\r\n\r\n/**\r\n * Territory renderer.\r\n * Renders territory colors on the map (e.g. player territories).\r\n * @internal\r\n */\r\nclass TerritoryRenderer extends CachedLayer {\r\n\tinvalidateCaches(): void {\r\n\t\tthis.resizeCanvas(gameMap.width, gameMap.height);\r\n\t}\r\n\r\n\tonMapMove(this: void, x: number, y: number): void {\r\n\t\tterritoryRenderer.dx = x;\r\n\t\tterritoryRenderer.dy = y;\r\n\t}\r\n\r\n\tonMapScale(this: void, scale: number): void {\r\n\t\tterritoryRenderer.scale = scale;\r\n\t}\r\n}\r\n\r\nexport const territoryRenderer = new TerritoryRenderer();\r\n\r\nmapTransformHandler.scale.register(territoryRenderer.onMapScale);\r\nmapTransformHandler.move.register(territoryRenderer.onMapMove);","import {Player} from \"../../game/player/Player\";\r\nimport {gameMap, isPlaying} from \"../../game/Game\";\r\nimport {getSetting, registerSettingListener} from \"../../util/UserSettingManager\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\nimport {territoryRenderer} from \"../layer/TerritoryRenderer\";\r\nimport {playerManager} from \"../../game/player/PlayerManager\";\r\nimport {territoryManager} from \"../../game/TerritoryManager\";\r\nimport {GameTheme} from \"../GameTheme\";\r\n\r\n/**\r\n * When a player claims a tile, three types of updates are required:\r\n * 1. The tile can become a border tile of the player's territory.\r\n * 2. The tile can become an inner tile of the player's territory.\r\n * 3. A neighboring tile can become a border tile of the player's territory.\r\n */\r\nclass TerritoryRenderingManager {\r\n\tprivate readonly territoryQueue: Array<number> = [];\r\n\tprivate readonly playerBorderQueue: Array<number> = [];\r\n\tprivate readonly targetBorderQueue: Array<number> = [];\r\n\r\n\t/**\r\n\t * Add a tile to the territory update queue.\r\n\t * @param tile index of the tile\r\n\t */\r\n\tsetTerritory(tile: number): void {\r\n\t\tthis.territoryQueue.push(tile);\r\n\t}\r\n\r\n\t/**\r\n\t * Add a border to the territory update queue.\r\n\t * @param tile index of the tile\r\n\t */\r\n\tsetPlayerBorder(tile: number): void {\r\n\t\tthis.playerBorderQueue.push(tile);\r\n\t}\r\n\r\n\t/**\r\n\t * Add a border to the territory update queue.\r\n\t * @param tile index of the tile\r\n\t */\r\n\tsetTargetBorder(tile: number): void {\r\n\t\tthis.targetBorderQueue.push(tile);\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the tile at the given index.\r\n\t * @param tile index of the tile\r\n\t */\r\n\tclear(tile: number): void {\r\n\t\tterritoryRenderer.context.clearRect(tile % gameMap.width, Math.floor(tile / gameMap.width), 1, 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Execute the transaction.\r\n\t * @param player the player to apply the transaction to\r\n\t * @param target the target player\r\n\t * @internal\r\n\t */\r\n\tapplyTransaction(player: Player, target: Player): void {\r\n\t\tthis.paintTiles(this.targetBorderQueue, getSetting(\"theme\").getBorderColor(target.baseColor));\r\n\t\tthis.paintTiles(this.playerBorderQueue, getSetting(\"theme\").getBorderColor(player.baseColor));\r\n\t\tthis.paintTiles(this.territoryQueue, getSetting(\"theme\").getTerritoryColor(player.baseColor));\r\n\r\n\t\tthis.targetBorderQueue.length = 0;\r\n\t\tthis.playerBorderQueue.length = 0;\r\n\t\tthis.territoryQueue.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Paint a tile.\r\n\t * @param tiles the tiles to paint\r\n\t * @param color the color to paint the tiles\r\n\t */\r\n\tprivate paintTiles(tiles: number[], color: HSLColor): void {\r\n\t\tconst context = territoryRenderer.context;\r\n\t\tcontext.fillStyle = color.toString();\r\n\t\tif (color.a < 1) {\r\n\t\t\tfor (const tile of tiles) {\r\n\t\t\t\tcontext.clearRect(tile % gameMap.width, Math.floor(tile / gameMap.width), 1, 1);\r\n\t\t\t\tcontext.fillRect(tile % gameMap.width, Math.floor(tile / gameMap.width), 1, 1);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const tile of tiles) {\r\n\t\t\t\tcontext.fillRect(tile % gameMap.width, Math.floor(tile / gameMap.width), 1, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Force a repaint of the territory layer.\r\n\t */\r\n\tforceRepaint(this: void, theme: GameTheme): void {\r\n\t\tif (!isPlaying) return;\r\n\t\tterritoryRenderer.context.clearRect(0, 0, gameMap.width, gameMap.height);\r\n\t\tconst colorCache: string[] = [];\r\n\t\tfor (let i = 0; i < gameMap.width * gameMap.height; i++) {\r\n\t\t\tconst owner = territoryManager.getOwner(i);\r\n\t\t\tif (owner !== territoryManager.OWNER_NONE && owner !== territoryManager.OWNER_NONE - 1) {\r\n\t\t\t\tconst player = playerManager.getPlayer(owner);\r\n\t\t\t\tconst isTerritory = territoryManager.isTerritory(i);\r\n\t\t\t\tconst index = (owner << 1) + (isTerritory ? 1 : 0);\r\n\t\t\t\tif (!colorCache[index]) {\r\n\t\t\t\t\tcolorCache[index] = isTerritory ? theme.getTerritoryColor(player.baseColor).toString() : theme.getBorderColor(player.baseColor).toString();\r\n\t\t\t\t}\r\n\t\t\t\tterritoryRenderer.context.fillStyle = colorCache[index];\r\n\t\t\t\tterritoryRenderer.context.fillRect(i % gameMap.width, Math.floor(i / gameMap.width), 1, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const territoryRenderingManager = new TerritoryRenderingManager();\r\n\r\nregisterSettingListener(\"theme\", territoryRenderingManager.forceRepaint);","import {Player} from \"../player/Player\";\r\nimport {PriorityQueue} from \"../../util/PriorityQueue\";\r\nimport {territoryManager} from \"../TerritoryManager\";\r\nimport {gameMap} from \"../Game\";\r\nimport {bordersTile, onNeighbors} from \"../../util/MathUtil\";\r\nimport {random} from \"../Random\";\r\nimport {attackActionHandler} from \"./AttackActionHandler\";\r\nimport {territoryRenderingManager} from \"../../renderer/manager/TerritoryRenderingManager\";\r\nimport {playerNameRenderingManager} from \"../../renderer/manager/PlayerNameRenderingManager\";\r\n\r\nexport class AttackExecutor {\r\n\treadonly player: Player;\r\n\treadonly target: Player | null;\r\n\tprivate troops: number;\r\n\tprivate tileQueue: PriorityQueue<[number, number]> = new PriorityQueue((a, b) => a[0] < b[0]);\r\n\tprivate basePriority: number = 0;\r\n\r\n\t/**\r\n\t * Create a new attack executor.\r\n\t * @param player The player that is attacking.\r\n\t * @param target The player that is being attacked, or null if the target is unclaimed territory.\r\n\t * @param troops The amount of troops that are attacking.\r\n\t * @param borderTiles The tiles from which the attack is executed, or null to use the player's border tiles.\r\n\t */\r\n\tconstructor(player: Player, target: Player | null, troops: number, borderTiles: Set<number> | null = null) {\r\n\t\tthis.player = player;\r\n\t\tthis.target = target;\r\n\t\tthis.troops = troops;\r\n\t\tthis.orderTiles(borderTiles);\r\n\t}\r\n\r\n\t/**\r\n\t * Modify the amount of troops in the attack.\r\n\t * @param amount The amount to modify the troops by.\r\n\t */\r\n\tmodifyTroops(amount: number): void {\r\n\t\tthis.troops += amount;\r\n\t}\r\n\r\n\t/**\r\n\t * Oppose an attack on the player.\r\n\t * @param troopCount The amount of troops that are opposing the attack.\r\n\t * @returns Whether the attack is still ongoing.\r\n\t */\r\n\toppose(troopCount: number): boolean {\r\n\t\tif (this.troops > troopCount) {\r\n\t\t\tthis.troops -= troopCount;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the amount of troops in the attack.\r\n\t * The troop count decreases as the attack progresses.\r\n\t * @returns The amount of troops in the attack.\r\n\t */\r\n\tgetTroops(): number {\r\n\t\treturn this.troops;\r\n\t}\r\n\r\n\t/**\r\n\t * Tick the attack executor.\r\n\t * @returns Whether the attack is still ongoing.\r\n\t */\r\n\ttick(): boolean {\r\n\t\tconst attackCost = this.calculateAttackCost();\r\n\t\tconst defenseCost = Math.ceil((1 + attackCost) / 2);\r\n\r\n\t\tlet conquered = 0;\r\n\t\twhile (this.troops >= attackCost && !this.tileQueue.isEmpty() && this.tileQueue.peek()[0] < this.basePriority) {\r\n\t\t\tconst [_, tile] = this.tileQueue.pop();\r\n\t\t\tif (!territoryManager.isOwner(tile, this.target ? this.target.id : territoryManager.OWNER_NONE)) continue;\r\n\t\t\tif (!bordersTile(tile, this.player.id)) continue;\r\n\t\t\tterritoryManager.conquer(tile, this.player.id);\r\n\r\n\t\t\tthis.troops -= attackCost + gameMap.tileExpansionCosts[tile] / 50;\r\n\t\t\tconquered++;\r\n\t\t}\r\n\r\n\t\tterritoryRenderingManager.applyTransaction(this.player, this.target || this.player);\r\n\t\tplayerNameRenderingManager.applyTransaction(this.player, this.target || this.player);\r\n\r\n\t\tif (this.target) this.target.removeTroops(conquered * defenseCost);\r\n\r\n\t\tif (this.tileQueue.isEmpty() || this.troops < attackCost) return false;\r\n\r\n\t\tthis.basePriority += this.calculateSpeedFactor();\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Handle the addition of a tile to the player's territory.\r\n\t * Called when a new tile is added to the player's territory (including by this attack).\r\n\t * @param tile The tile that was added.\r\n\t */\r\n\thandlePlayerTileAdd(tile: number) {\r\n\t\tonNeighbors(tile, neighbor => {\r\n\t\t\tif (territoryManager.isOwner(neighbor, this.target ? this.target.id : territoryManager.OWNER_NONE)) {\r\n\t\t\t\tthis.tileQueue.push([this.basePriority + gameMap.tileExpansionTimes[tile] * (0.025 + random.next() * 0.06), neighbor]);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Handle the addition of a tile to the target's territory.\r\n\t * Called when a new tile is added to the target's territory.\r\n\t * @param tile The tile that was added.\r\n\t */\r\n\thandleTargetTileAdd(tile: number) {\r\n\t\tif (bordersTile(tile, this.player.id)) {\r\n\t\t\tthis.tileQueue.push([this.basePriority + gameMap.tileExpansionTimes[tile] * (0.025 + random.next() * 0.06), tile]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Build the initial tile queue.\r\n\t * @param borderTiles The tiles to calculate initial tile queue from, or null to use the player's border tiles.\r\n\t * @private\r\n\t */\r\n\tprivate orderTiles(borderTiles: Set<number> | null = null): void {\r\n\t\tconst tileOwners = territoryManager.tileOwners;\r\n\t\tconst target = this.target ? this.target.id : territoryManager.OWNER_NONE;\r\n\r\n\t\tconst result = [];\r\n\t\tconst amountCache = attackActionHandler.amountCache;\r\n\t\tfor (const tile of borderTiles || this.player.borderTiles) {\r\n\t\t\tconst x = tile % gameMap.width;\r\n\t\t\tconst y = Math.floor(tile / gameMap.width);\r\n\t\t\tif (x > 0 && tileOwners[tile - 1] === target) {\r\n\t\t\t\tif (!amountCache[tile - 1]) result.push(tile - 1);\r\n\t\t\t\tamountCache[tile - 1]++;\r\n\t\t\t}\r\n\t\t\tif (x < gameMap.width - 1 && tileOwners[tile + 1] === target) {\r\n\t\t\t\tif (!amountCache[tile + 1]) result.push(tile + 1);\r\n\t\t\t\tamountCache[tile + 1]++;\r\n\t\t\t}\r\n\t\t\tif (y > 0 && tileOwners[tile - gameMap.width] === target) {\r\n\t\t\t\tif (!amountCache[tile - gameMap.width]) result.push(tile - gameMap.width);\r\n\t\t\t\tamountCache[tile - gameMap.width]++;\r\n\t\t\t}\r\n\t\t\tif (y < gameMap.height - 1 && tileOwners[tile + gameMap.width] === target) {\r\n\t\t\t\tif (!amountCache[tile + gameMap.width]) result.push(tile + gameMap.width);\r\n\t\t\t\tamountCache[tile + gameMap.width]++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (const tile of result) {\r\n\t\t\tconst priority = 4 - amountCache[tile] + random.next() * 3;\r\n\t\t\tamountCache[tile] = 0;\r\n\t\t\tthis.tileQueue.push([gameMap.tileExpansionTimes[tile] * priority / 50, tile]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calculate the speed factor of the attack.\r\n\t * The speed factor is a value between that determines how fast the attack progresses, higher values mean faster attacks.\r\n\t * @returns The speed factor of the attack.\r\n\t * @private\r\n\t */\r\n\tprivate calculateSpeedFactor(): number {\r\n\t\tif (!this.target) return 1;\r\n\t\treturn 0.65 + Math.log(1 + Math.min(50, this.player.getTerritorySize() * this.player.getTroops() / Math.max(1, this.target.getTerritorySize()) / Math.max(1, this.target.getTroops()))) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculate the cost of attacking the target.\r\n\t * The cost is the amount of troops that are required to conquer a single pixel of the target's territory.\r\n\t * This does not include the base cost of conquering a tile.\r\n\t * @returns The cost of attacking the target.\r\n\t * @private\r\n\t */\r\n\tprivate calculateAttackCost() {\r\n\t\tif (!this.target) return 0;\r\n\t\treturn Math.min(20, Math.floor(this.target.getTroops() / Math.max(1, this.player.getTroops()) * 3));\r\n\t}\r\n}","import {playerManager} from \"../player/PlayerManager\";\r\nimport {gameTicker} from \"../GameTicker\";\r\nimport {territoryManager} from \"../TerritoryManager\";\r\nimport {Player} from \"../player/Player\";\r\nimport {AttackExecutor} from \"./AttackExecutor\";\r\nimport {gameMap, gameMode} from \"../Game\";\r\n\r\nclass AttackActionHandler {\r\n\tprivate attacks: AttackExecutor[] = [];\r\n\tprivate playerIndex: (AttackExecutor | null)[][] = [];\r\n\tprivate unclaimedIndex: (AttackExecutor | null)[] = [];\r\n\tprivate playerAttackList: AttackExecutor[][] = [];\r\n\tprivate targetAttackList: AttackExecutor[][] = [];\r\n\tprivate unclaimedAttackList: AttackExecutor[] = [];\r\n\tamountCache: Uint8Array;\r\n\r\n\tinit(maxPlayers: number): void {\r\n\t\tthis.attacks = [];\r\n\t\tthis.playerIndex = new Array(maxPlayers).fill(null).map(() => new Array<AttackExecutor | null>(maxPlayers).fill(null));\r\n\t\tthis.playerAttackList = new Array(maxPlayers).fill(null).map(() => []);\r\n\t\tthis.targetAttackList = new Array(maxPlayers).fill(null).map(() => []);\r\n\t\tthis.unclaimedIndex = [];\r\n\t\tthis.amountCache = new Uint8Array(gameMap.width * gameMap.height);\r\n\t}\r\n\r\n\t//TODO: Move this out of here\r\n\tpreprocessAttack(player: number, target: number, percentage: number): void {\r\n\t\tif (!gameMode.canAttack(player, target)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst troopCount = Math.floor(playerManager.getPlayer(player).getTroops() * percentage);\r\n\t\tplayerManager.getPlayer(player).removeTroops(troopCount);\r\n\r\n\t\tif (target === territoryManager.OWNER_NONE) {\r\n\t\t\tthis.attackUnclaimed(playerManager.getPlayer(player), troopCount);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.attackPlayer(playerManager.getPlayer(player), playerManager.getPlayer(target), troopCount);\r\n\t}\r\n\r\n\t//TODO: Remove this once we have proper attack buttons\r\n\thasBorderWith(player: Player, target: number): boolean {\r\n\t\tfor (const tile of player.borderTiles) {\r\n\t\t\tconst x = tile % gameMap.width;\r\n\t\t\tconst y = Math.floor(tile / gameMap.width);\r\n\t\t\tif (x > 0 && territoryManager.isOwner(tile - 1, target)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (x < gameMap.width - 1 && territoryManager.isOwner(tile + 1, target)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (y > 0 && territoryManager.isOwner(tile - gameMap.width, target)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (y < gameMap.height - 1 && territoryManager.isOwner(tile + gameMap.width, target)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Schedule an attack on an unclaimed territory.\r\n\t * @param player The player that is attacking.\r\n\t * @param troops The amount of troops that are attacking.\r\n\t * @param borderTiles The tiles from which the attack is executed, or null to use the player's border tiles.\r\n\t */\r\n\tattackUnclaimed(player: Player, troops: number, borderTiles: Set<number> | null = null): void {\r\n\t\tconst parent = this.unclaimedIndex[player.id];\r\n\t\tif (parent) {\r\n\t\t\tparent.modifyTroops(troops);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.addUnclaimed(player, troops, borderTiles);\r\n\t}\r\n\r\n\t/**\r\n\t * Schedule an attack on a player.\r\n\t * @param player The player that is attacking.\r\n\t * @param target The player that is being attacked.\r\n\t * @param troops The amount of troops that are attacking.\r\n\t * @param borderTiles The tiles from which the attack is executed, or null to use the player's border tiles.\r\n\t */\r\n\tattackPlayer(player: Player, target: Player, troops: number, borderTiles: Set<number> | null = null): void {\r\n\t\tconst parent = this.getAttack(player, target);\r\n\t\tif (parent) {\r\n\t\t\tparent.modifyTroops(troops);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst opposite = this.getAttack(target, player);\r\n\t\tif (opposite) {\r\n\t\t\tif (opposite.oppose(troops)) return;\r\n\t\t\tthis.removeAttack(opposite);\r\n\t\t\ttroops -= opposite.getTroops();\r\n\t\t}\r\n\r\n\t\tthis.addAttack(player, target, troops, borderTiles);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the attack executor for the given players.\r\n\t * @param player The player that is attacking.\r\n\t * @param target The player that is being attacked.\r\n\t * @returns The attack executor for the given players.\r\n\t * @private\r\n\t */\r\n\tprivate getAttack(player: Player, target: Player): AttackExecutor | null {\r\n\t\treturn this.playerIndex[player.id][target.id];\r\n\t}\r\n\r\n\t/**\r\n\t * Add an unclaimed attack to the list of ongoing attacks.\r\n\t * @param player The player that is attacking.\r\n\t * @param troops The amount of troops that are attacking.\r\n\t * @param borderTiles The tiles from which the attack is executed, or null to use the player's border tiles.\r\n\t * @private\r\n\t */\r\n\tprivate addUnclaimed(player: Player, troops: number, borderTiles: Set<number> | null = null): void {\r\n\t\tconst attack = new AttackExecutor(player, null, troops, borderTiles);\r\n\t\tthis.attacks.push(attack);\r\n\t\tthis.unclaimedIndex[player.id] = attack;\r\n\t\tthis.playerAttackList[player.id].push(attack);\r\n\t\tthis.unclaimedAttackList.push(attack);\r\n\t}\r\n\r\n\t/**\r\n\t * Add an attack to the list of ongoing attacks.\r\n\t * @param player The player that is attacking.\r\n\t * @param target The player that is being attacked.\r\n\t * @param troops The amount of troops that are attacking.\r\n\t * @param borderTiles The tiles from which the attack is executed, or null to use the player's border tiles.\r\n\t * @private\r\n\t */\r\n\tprivate addAttack(player: Player, target: Player, troops: number, borderTiles: Set<number> | null = null): void {\r\n\t\tconst attack = new AttackExecutor(player, target, troops, borderTiles);\r\n\t\tthis.attacks.push(attack);\r\n\t\tthis.playerIndex[player.id][target.id] = attack;\r\n\t\tthis.playerAttackList[player.id].push(attack);\r\n\t\tthis.targetAttackList[target.id].push(attack);\r\n\t}\r\n\r\n\t/**\r\n\t * Remove an attack from the list of ongoing attacks.\r\n\t * @param attack The attack to remove.\r\n\t * @private\r\n\t */\r\n\tprivate removeAttack(attack: AttackExecutor): void {\r\n\t\tthis.attacks.splice(this.attacks.indexOf(attack), 1);\r\n\t\tthis.playerAttackList[attack.player.id].splice(this.playerAttackList[attack.player.id].indexOf(attack), 1);\r\n\t\tif (attack.target) {\r\n\t\t\tthis.playerIndex[attack.player.id][attack.target.id] = null;\r\n\t\t\tthis.targetAttackList[attack.target.id].splice(this.targetAttackList[attack.target.id].indexOf(attack), 1);\r\n\t\t} else {\r\n\t\t\tthis.unclaimedIndex[attack.player.id] = null;\r\n\t\t\tthis.unclaimedAttackList.splice(this.unclaimedAttackList.indexOf(attack), 1);\r\n\t\t}\r\n\t}\r\n\r\n\ttick(): void {\r\n\t\tfor (const attack of this.attacks) {\r\n\t\t\tif (attack.tick()) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tplayerManager.getPlayer(attack.player.id).addTroops(attack.getTroops());\r\n\t\t\tthis.removeAttack(attack);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handle a tile being added to a player.\r\n\t * @param tile The tile that was added.\r\n\t * @param player The player that the tile was added to.\r\n\t */\r\n\thandleTerritoryAdd(tile: number, player: number): void {\r\n\t\tfor (let i = 0; i < this.playerAttackList[player].length; i++) {\r\n\t\t\tthis.playerAttackList[player][i].handlePlayerTileAdd(tile);\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < this.targetAttackList[player].length; i++) {\r\n\t\t\tthis.targetAttackList[player][i].handleTargetTileAdd(tile);\r\n\t\t}\r\n\t}\r\n\r\n\tclear(): void {\r\n\t\tthis.attacks = [];\r\n\t\tthis.playerIndex = [];\r\n\t}\r\n}\r\n\r\nexport const attackActionHandler = new AttackActionHandler();\r\n\r\ngameTicker.registry.register(attackActionHandler.tick.bind(attackActionHandler));","import {territoryManager} from \"../TerritoryManager\";\r\nimport {onNeighbors} from \"../../util/MathUtil\";\r\nimport {playerNameRenderingManager} from \"../../renderer/manager/PlayerNameRenderingManager\";\r\nimport {attackActionHandler} from \"../attack/AttackActionHandler\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\nimport {territoryRenderingManager} from \"../../renderer/manager/TerritoryRenderingManager\";\r\nimport {gameMode} from \"../Game\";\r\n\r\nexport class Player {\r\n\treadonly id: number;\r\n\treadonly name: string;\r\n\treadonly baseColor: HSLColor;\r\n\tprivate troops: number = 1000;\r\n\treadonly borderTiles: Set<number> = new Set();\r\n\tprivate territorySize: number = 0;\r\n\tprivate alive: boolean = true;\r\n\r\n\tconstructor(id: number, name: string, baseColor: HSLColor) {\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t\tthis.baseColor = gameMode.processPlayerColor(id, baseColor);\r\n\t}\r\n\r\n\t/**\r\n\t * Add a tile to the player's territory.\r\n\t * WARNING: Make sure to call this method AFTER updating the territory manager.\r\n\t * @param tile\r\n\t * @internal\r\n\t */\r\n\taddTile(tile: number): void {\r\n\t\tthis.territorySize++;\r\n\t\tif (territoryManager.isBorder(tile)) {\r\n\t\t\tthis.borderTiles.add(tile);\r\n\t\t\tterritoryRenderingManager.setPlayerBorder(tile);\r\n\t\t} else {\r\n\t\t\tplayerNameRenderingManager.addTile(tile);\r\n\t\t\tterritoryRenderingManager.setTerritory(tile);\r\n\t\t}\r\n\t\tonNeighbors(tile, neighbor => {\r\n\t\t\tif (territoryManager.isOwner(neighbor, this.id) && !territoryManager.isBorder(neighbor) && this.borderTiles.delete(neighbor)) {\r\n\t\t\t\tterritoryRenderingManager.setTerritory(neighbor);\r\n\t\t\t\tplayerNameRenderingManager.addTile(neighbor);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tattackActionHandler.handleTerritoryAdd(tile, this.id);\r\n\t}\r\n\r\n\t/**\r\n\t * Remove a tile from the player's territory.\r\n\t * WARNING: Make sure to call this method AFTER updating the territory manager.\r\n\t * @param tile The tile to remove.\r\n\t * @internal\r\n\t */\r\n\tremoveTile(tile: number): void {\r\n\t\tthis.territorySize--;\r\n\t\tif (!this.borderTiles.delete(tile)) {\r\n\t\t\tplayerNameRenderingManager.removeTile(tile);\r\n\t\t}\r\n\t\tonNeighbors(tile, neighbor => {\r\n\t\t\tif (territoryManager.isOwner(neighbor, this.id) && !this.borderTiles.has(neighbor)) {\r\n\t\t\t\tthis.borderTiles.add(neighbor);\r\n\t\t\t\tterritoryRenderingManager.setTargetBorder(neighbor);\r\n\t\t\t\tplayerNameRenderingManager.removeTile(neighbor);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (this.territorySize === 0) {\r\n\t\t\tthis.alive = false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Process one tick worth of income.\r\n\t */\r\n\tincome(territoryMultiplier: number) {\r\n\t\t//this.addTroops(Math.max(1, Math.floor((this.territorySize * territoryMultiplier) + Math.floor(this.troops / 30))));\r\n\t}\r\n\r\n\t/**\r\n\t * @returns The amount of troops the player has.\r\n\t */\r\n\tgetTroops(): number {\r\n\t\treturn this.troops;\r\n\t}\r\n\r\n\t/**\r\n\t * Add troops to the player.\r\n\t * Troops will be capped at 100 times the territory size.\r\n\t * @param amount The amount of troops to add.\r\n\t */\r\n\taddTroops(amount: number) {\r\n\t\tthis.troops = Math.min(this.territorySize * 100, this.troops + amount);\r\n\t}\r\n\r\n\t/**\r\n\t * Remove troops from the player.\r\n\t * @param amount The amount of troops to remove.\r\n\t */\r\n\tremoveTroops(amount: number) {\r\n\t\tthis.troops = Math.max(0, this.troops - amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns The size of the player's territory (in tiles).\r\n\t */\r\n\tgetTerritorySize(): number {\r\n\t\treturn this.territorySize;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns True if the player is alive, false otherwise.\r\n\t */\r\n\tisAlive(): boolean {\r\n\t\treturn this.alive;\r\n\t}\r\n}","import {Player} from \"./Player\";\r\nimport {territoryManager} from \"../TerritoryManager\";\r\nimport {random} from \"../Random\";\r\nimport {attackActionHandler} from \"../attack/AttackActionHandler\";\r\nimport {onNeighbors} from \"../../util/MathUtil\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\n\r\nexport class BotPlayer extends Player {\r\n\tconstructor(id: number) {\r\n\t\tsuper(id, \"Bot\", HSLColor.fromRGB(Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)));\r\n\t}\r\n\r\n\t//TODO: Implement bot logic\r\n\ttick(): void {\r\n\t\tif (random.nextInt(20) < 19) return;\r\n\t\tconst targets: number[] = [];\r\n\t\tfor (const border of this.borderTiles) {\r\n\t\t\tonNeighbors(border, neighbor => {\r\n\t\t\t\tconst owner = territoryManager.getOwner(neighbor);\r\n\t\t\t\tif (owner !== this.id && !targets.includes(owner)) {\r\n\t\t\t\t\ttargets.push(owner);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (targets.length < 1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (targets.includes(territoryManager.OWNER_NONE)) {\r\n\t\t\tattackActionHandler.preprocessAttack(this.id, territoryManager.OWNER_NONE, 0.1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tattackActionHandler.preprocessAttack(this.id, targets[random.nextInt(targets.length)], 0.1);\r\n\t}\r\n}","import {random} from \"../Random\";\r\nimport {gameMap, isLocalGame, startGameCycle} from \"../Game\";\r\nimport {territoryManager} from \"../TerritoryManager\";\r\nimport {Player} from \"./Player\";\r\nimport {territoryRenderingManager} from \"../../renderer/manager/TerritoryRenderingManager\";\r\nimport {playerNameRenderingManager} from \"../../renderer/manager/PlayerNameRenderingManager\";\r\n\r\nclass SpawnManager {\r\n\tspawnPoints: number[];\r\n\tspawnData: SpawnData[];\r\n\tbackupPoints: number[];\r\n\tisSelecting: boolean;\r\n\r\n\t/**\r\n\t * Initialize the spawn manager with the given maximum number of players.\r\n\t *\r\n\t * The spawn points are generated based on the map size and the number of players.\r\n\t * Since the spawn points are generated randomly, the actual number of spawn points may be lower than the maximum number of players.\r\n\t * If this is the case, spawn points will be regenerated with a smaller radius until enough spawn points are available.\r\n\t * @param maxPlayers The maximum number of players.\r\n\t */\r\n\tinit(maxPlayers: number): void {\r\n\t\tlet radius = Math.max(5, Math.sqrt(gameMap.width * gameMap.height / maxPlayers / 1.1 / Math.sqrt(2)));\r\n\t\twhile (radius >= 5) {\r\n\t\t\tthis.spawnPoints = this.buildSpawns(radius);\r\n\t\t\tif (this.spawnPoints.length >= maxPlayers) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tradius *= 0.9;\r\n\t\t}\r\n\r\n\t\tthis.spawnData = [];\r\n\t\tthis.backupPoints = [];\r\n\t\tthis.isSelecting = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Build spawn points with the given radius.\r\n\t *\r\n\t * The spawn points are generated using poisson disc sampling.\r\n\t * Algorithm by Robert Bridson (https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf)\r\n\t * Results are filtered to only include spawn points on solid tiles.\r\n\t * @param radius The radius of the spawn points.\r\n\t * @private\r\n\t */\r\n\tprivate buildSpawns(radius: number): number[] {\r\n\t\tconst minDistance = radius * radius;\r\n\t\tconst cellSize = radius / Math.sqrt(2);\r\n\t\tconst rows = Math.ceil(gameMap.height / cellSize);\r\n\t\tconst cols = Math.ceil(gameMap.width / cellSize);\r\n\t\tconst grid: number[] = new Array<number>(rows * cols).fill(-1);\r\n\t\tconst active = [], points = [];\r\n\t\tconst initialX = random.nextInt(gameMap.width), initialY = random.nextInt(gameMap.height);\r\n\t\tconst initial = initialX + initialY * gameMap.width;\r\n\t\tactive.push(initial);\r\n\t\tpoints.push(initial);\r\n\t\tgrid[Math.floor(initialX / cellSize) + Math.floor(initialY / cellSize) * cols] = initial;\r\n\t\twhile (active.length > 0) {\r\n\t\t\tconst index = random.nextInt(active.length);\r\n\t\t\tconst point = active[index];\r\n\t\t\tconst px = point % gameMap.width;\r\n\t\t\tconst py = Math.floor(point / gameMap.width);\r\n\t\t\tlet found = false;\r\n\t\t\tfor (let tries = 0; tries < 30; tries++) {\r\n\t\t\t\tconst angle = random.next() * 2 * Math.PI;\r\n\t\t\t\tconst distance = (random.next() + 1) * radius;\r\n\t\t\t\tconst x = Math.floor(px + Math.cos(angle) * distance);\r\n\t\t\t\tconst y = Math.floor(py + Math.sin(angle) * distance);\r\n\t\t\t\tconst cellX = Math.floor(x / cellSize);\r\n\t\t\t\tconst cellY = Math.floor(y / cellSize);\r\n\t\t\t\tif (x < 0 || x >= gameMap.width || y < 0 || y >= gameMap.height || grid[cellX + cellY * cols] !== -1) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tlet valid = true;\r\n\t\t\t\tfor (let i = -1; i <= 1; i++) {\r\n\t\t\t\t\tfor (let j = -1; j <= 1; j++) {\r\n\t\t\t\t\t\tif (cellX + i < 0 || cellX + i >= cols || cellY + j < 0 || cellY + j >= rows) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (grid[cellX + i + (cellY + j) * cols] !== -1) {\r\n\t\t\t\t\t\t\tconst other = grid[cellX + i + (cellY + j) * cols];\r\n\t\t\t\t\t\t\tconst ox = other % gameMap.width - x;\r\n\t\t\t\t\t\t\tconst oy = Math.floor(other / gameMap.width) - y;\r\n\t\t\t\t\t\t\tif (ox * ox + oy * oy < minDistance) {\r\n\t\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!valid) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (valid) {\r\n\t\t\t\t\tfound = true;\r\n\t\t\t\t\tconst index = x + y * gameMap.width;\r\n\t\t\t\t\tactive.push(index);\r\n\t\t\t\t\tif (gameMap.getTile(index).isSolid) {\r\n\t\t\t\t\t\tpoints.push(index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgrid[Math.floor(x / cellSize) + Math.floor(y / cellSize) * cols] = index;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!found) {\r\n\t\t\t\tactive.splice(index, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\t}\r\n\r\n\t/**\r\n\t * Select a random spawn point for the given player.\r\n\t *\r\n\t * The spawn point is selected from the available spawn points.\r\n\t * If no spawn points are available, the player will be spawned at partially blocked spawn points.\r\n\t * @param player The player to spawn.\r\n\t * @returns The selected spawn point.\r\n\t */\r\n\trandomSpawnPoint(player: Player): number {\r\n\t\tconst target = this.spawnPoints.length > 0 ? this.spawnPoints : this.backupPoints;\r\n\t\tconst index = random.nextInt(target.length);\r\n\t\tconst result = target[index];\r\n\t\ttarget.splice(index, 1);\r\n\t\tthis.getSpawnPixels(result).forEach(pixel => territoryManager.conquer(pixel, player.id));\r\n\t\tterritoryRenderingManager.applyTransaction(player, player);\r\n\t\tplayerNameRenderingManager.applyTransaction(player, player);\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Select a spawn point for the given player based on the selected tile.\r\n\t *\r\n\t * Marks spawn points near the selected tile as blocked, so random spawn points will not be selected near the selected tile.\r\n\t * @param player The player to spawn.\r\n\t * @param tile The selected tile.\r\n\t */\r\n\tselectSpawnPoint(player: Player, tile: number): void {\r\n\t\tif (this.spawnData[player.id]) {\r\n\t\t\tthis.spawnData[player.id].pixels.forEach(pixel => territoryManager.clear(pixel));\r\n\t\t\tthis.spawnPoints.push(...this.spawnData[player.id].blockedPoints);\r\n\t\t\tthis.spawnData[player.id].blockedPoints.forEach(point => this.backupPoints.splice(this.backupPoints.indexOf(point), 1));\r\n\t\t}\r\n\r\n\t\t//TODO: Check if the selected tile is a valid spawn point\r\n\t\tconst data = new SpawnData();\r\n\t\tdata.blockedPoints = this.spawnPoints.filter(point => Math.abs(point % gameMap.width - tile % gameMap.width) <= 4 && Math.abs(Math.floor(point / gameMap.width) - Math.floor(tile / gameMap.width)) <= 4);\r\n\t\tdata.pixels = this.getSpawnPixels(tile);\r\n\t\tdata.blockedPoints.forEach(point => this.spawnPoints.splice(this.spawnPoints.indexOf(point), 1));\r\n\t\tdata.pixels.forEach(pixel => territoryManager.conquer(pixel, player.id));\r\n\t\tthis.backupPoints.push(...data.blockedPoints);\r\n\t\tthis.spawnData[player.id] = data;\r\n\t\tterritoryRenderingManager.applyTransaction(player, player);\r\n\t\tplayerNameRenderingManager.applyTransaction(player, player);\r\n\r\n\t\tif (isLocalGame) {\r\n\t\t\tthis.isSelecting = false;\r\n\t\t\tstartGameCycle();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get the spawn points near the given tile (within a 5x5 area).\r\n\t * @param tile The tile to get the spawn points for.\r\n\t * @returns The spawn points near the given tile.\r\n\t * @private\r\n\t */\r\n\tprivate getSpawnPixels(tile: number): number[] {\r\n\t\tconst result = [];\r\n\t\tfor (let dx = -2; dx <= 2; dx++) {\r\n\t\t\tfor (let dy = -2; dy <= 2; dy++) {\r\n\t\t\t\tif (Math.abs(dx) === 2 && Math.abs(dy) === 2) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst index = tile + dx + dy * gameMap.width;\r\n\t\t\t\tif (index < 0 || index >= gameMap.width * gameMap.height) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (gameMap.getTile(index).isSolid && !territoryManager.hasOwner(index)) {\r\n\t\t\t\t\tresult.push(index);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\nclass SpawnData {\r\n\tblockedPoints: number[];\r\n\tpixels: number[];\r\n}\r\n\r\nexport const spawnManager = new SpawnManager();","import {GameMap} from \"../map/GameMap\";\r\nimport {mapNavigationHandler} from \"./action/MapNavigationHandler\";\r\nimport {territoryManager} from \"./TerritoryManager\";\r\nimport {playerManager} from \"./player/PlayerManager\";\r\nimport {Player} from \"./player/Player\";\r\nimport {mapActionHandler} from \"./action/MapActionHandler\";\r\nimport {spawnManager} from \"./player/SpawnManager\";\r\nimport {random} from \"./Random\";\r\nimport {gameTicker} from \"./GameTicker\";\r\nimport {playerNameRenderingManager} from \"../renderer/manager/PlayerNameRenderingManager\";\r\nimport {attackActionHandler} from \"./attack/AttackActionHandler\";\r\nimport {HSLColor} from \"../util/HSLColor\";\r\nimport {GameMode} from \"./mode/GameMode\";\r\nimport {getSetting} from \"../util/UserSettingManager\";\r\nimport {gameRenderer} from \"../renderer/GameRenderer\";\r\nimport {boatManager} from \"./boat/BoatManager\";\r\n\r\n/**\r\n * The map of the current game.\r\n */\r\nexport let gameMap: GameMap;\r\n/**\r\n * The current game mode.\r\n */\r\nexport let gameMode: GameMode;\r\n/**\r\n * Whether the game is currently running.\r\n */\r\nexport let isPlaying: boolean;\r\n/**\r\n * Local games are directly played on the client without any server interaction.\r\n */\r\nexport let isLocalGame: boolean;\r\n\r\n/**\r\n * Start a new game with the given map.\r\n * @param map The map to start the game with.\r\n * @param mode The game mode to use.\r\n */\r\nexport function startGame(map: GameMap, mode: GameMode) {\r\n\tgameMap = map;\r\n\tgameMode = mode;\r\n\tmapNavigationHandler.enable();\r\n\tmapActionHandler.enable();\r\n\tterritoryManager.reset();\r\n\tboatManager.reset();\r\n\tgameRenderer.initGameplayLayers();\r\n\tplayerNameRenderingManager.reset(500);\r\n\tattackActionHandler.init(500);\r\n\tspawnManager.init(500);\r\n\tplayerManager.init([new Player(0, getSetting(\"playerName\") ?? \"UnknownPlayer\", HSLColor.fromRGB(0, 200, 200))], 0, 500);\r\n\r\n\tisPlaying = true;\r\n\tisLocalGame = true;\r\n\trandom.reset(23452345);\r\n}\r\n\r\n/**\r\n * Start the game cycle.\r\n * @internal This method is called by the spawn manager when the player has selected a spawn point.\r\n */\r\nexport function startGameCycle() {\r\n\tgameTicker.start();\r\n}","import {Player} from \"./Player\";\r\nimport {BotPlayer} from \"./BotPlayer\";\r\nimport {spawnManager} from \"./SpawnManager\";\r\nimport {gameTicker} from \"../GameTicker\";\r\nimport {playerNameRenderingManager} from \"../../renderer/manager/PlayerNameRenderingManager\";\r\n\r\nclass PlayerManager {\r\n\tprivate players: Player[];\r\n\tprivate bots: BotPlayer[];\r\n\tprivate incomeLoopLength: number = 250;\r\n\r\n\t/**\r\n\t * Initializes the player manager with the given players.\r\n\t * @param humans human players, one for local games, multiple for online games.\r\n\t * @param clientId Player ID of the client player (the player that is controlled this client).\r\n\t * @param maxPlayers The maximum number of players.\r\n\t */\r\n\tinit(humans: Player[], clientId: number, maxPlayers: number): void {\r\n\t\tthis.players = [];\r\n\t\tthis.bots = [];\r\n\r\n\t\tclientPlayer = humans[clientId];\r\n\t\tfor (const player of humans) {\r\n\t\t\tthis.registerPlayer(player, false);\r\n\t\t}\r\n\r\n\t\tfor (let i = humans.length; i < maxPlayers; i++) {\r\n\t\t\tthis.registerPlayer(new BotPlayer(this.players.length), true);\r\n\t\t}\r\n\r\n\t\tplayerNameRenderingManager.finishRegistration(this.players);\r\n\t}\r\n\r\n\t/**\r\n\t * Register a player.\r\n\t * @param player The player to register.\r\n\t * @param isBot Whether the player is a bot.\r\n\t */\r\n\tregisterPlayer(player: Player, isBot: boolean): void {\r\n\t\tplayerNameRenderingManager.registerPlayer(player);\r\n\t\tthis.players.push(player);\r\n\t\tif (isBot) {\r\n\t\t\tthis.bots.push(player as BotPlayer);\r\n\t\t\tspawnManager.randomSpawnPoint(player);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get the player with the given ID.\r\n\t * @param id The ID of the player.\r\n\t */\r\n\tgetPlayer(id: number): Player {\r\n\t\treturn this.players[id];\r\n\t}\r\n\r\n\t//TODO: bot ticking should be done in a separate bot manager\r\n\ttick(): void {\r\n\t\tthis.bots.forEach(bot => bot.tick());\r\n\t\tlet gameTick: number = gameTicker.getTickCount();\r\n\t\tif (gameTick % 10 === 0) {\r\n\t\t\tlet territoryMultiplier: number = (gameTick % this.incomeLoopLength) / (this.incomeLoopLength * 20);\r\n\t\t\tthis.players.forEach(player => player.income(territoryMultiplier));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const playerManager = new PlayerManager();\r\nexport let clientPlayer: Player;\r\n\r\ngameTicker.registry.register(playerManager.tick.bind(playerManager));","import {gameMap} from \"../../game/Game\";\r\nimport {territoryManager} from \"../../game/TerritoryManager\";\r\n\r\nclass AreaCalculator {\r\n\treadonly AREA_SIZE = 50;\r\n\tprivate graph: Area[]; //Temporary storage for the areas\r\n\tnodeIndex: Node[][];\r\n\tareaIndex: Uint16Array;\r\n\tisLoaded = false;\r\n\r\n\t/**\r\n\t * Preprocesses the map into areas.\r\n\t */\r\n\tpreprocessMap(): number {\r\n\t\tthis.isLoaded = true;\r\n\t\tthis.graph = [];\r\n\t\tthis.nodeIndex = [[]];\r\n\t\tthis.areaIndex = new Uint16Array(gameMap.width * gameMap.height);\r\n\t\tcurrentNodeId = 0;\r\n\t\tcanonicalAreaId = 1;\r\n\t\tthis.createAreas();\r\n\t\tfor (let i = 0; i < this.graph.length; i++) {\r\n\t\t\tconst area = this.graph[i];\r\n\t\t\t//We only need to check up and left since we only want each pair once.\r\n\t\t\tthis.checkConnections(area, area.x - this.AREA_SIZE, area.y);\r\n\t\t\tthis.checkConnections(area, area.x, area.y - this.AREA_SIZE);\r\n\r\n\t\t\tconst topLeft = area.nodes.find(node => node.x === area.x && node.y === area.y);\r\n\t\t\tconst topRight = this.graph[i - 1]?.nodes.find(node => node.x === area.x - 1 && node.y === area.y);\r\n\t\t\tconst bottomLeft = this.graph[i - Math.ceil(gameMap.width / this.AREA_SIZE)]?.nodes.find(node => node.x === area.x && node.y === area.y - 1);\r\n\t\t\tconst bottomRight = this.graph[i - Math.ceil(gameMap.width / this.AREA_SIZE) - 1]?.nodes.find(node => node.x === area.x - 1 && node.y === area.y - 1);\r\n\t\t\tif (topLeft && topRight && bottomLeft && bottomRight) {\r\n\t\t\t\ttopLeft.edges.push({node: bottomRight, cost: 1.5, cache: [bottomRight.x + bottomRight.y * gameMap.width]});\r\n\t\t\t\ttopRight.edges.push({node: bottomLeft, cost: 1.5, cache: [bottomLeft.x + bottomLeft.y * gameMap.width]});\r\n\t\t\t\tbottomLeft.edges.push({node: topRight, cost: 1.5, cache: [topRight.x + topRight.y * gameMap.width]});\r\n\t\t\t\tbottomRight.edges.push({node: topLeft, cost: 1.5, cache: [topLeft.x + topLeft.y * gameMap.width]});\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.buildAreaGraph();\r\n\t\tthis.graph = []; //no longer needed\r\n\t\treturn canonicalAreaId;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates areas for a specific level.\r\n\t */\r\n\tcreateAreas(): void {\r\n\t\tconst areas: Area[] = [];\r\n\t\tfor (let y = 0; y < gameMap.height; y += this.AREA_SIZE) {\r\n\t\t\tfor (let x = 0; x < gameMap.width; x += this.AREA_SIZE) {\r\n\t\t\t\tareas.push(new Area(x, y));\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.graph = areas;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if two areas are connected and adds an edge if they are connected.\r\n\t * @param area The area to check.\r\n\t * @param otherX The x-coordinate of the other area.\r\n\t * @param otherY The y-coordinate of the other area.\r\n\t */\r\n\tcheckConnections(area: Area, otherX: number, otherY: number): void {\r\n\t\tif (otherX < 0 || otherY < 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst x = area.x;\r\n\t\tconst y = area.y;\r\n\t\tconst map = territoryManager.tileOwners;\r\n\t\tconst allowed = territoryManager.OWNER_NONE - 1;\r\n\t\tconst other = this.graph[Math.floor(otherX / this.AREA_SIZE) + Math.floor(otherY / this.AREA_SIZE) * Math.ceil(gameMap.width / this.AREA_SIZE)];\r\n\t\tlet entranceStart = -1;\r\n\t\tif (area.x - otherX === 0) {\r\n\t\t\tfor (let i = 0; i < this.AREA_SIZE; i++) {\r\n\t\t\t\tif (x + i < gameMap.width && map[x + i + y * gameMap.width] === allowed && map[x + i + (y - 1) * gameMap.width] === allowed) {\r\n\t\t\t\t\tif (entranceStart === -1) {\r\n\t\t\t\t\t\tentranceStart = i;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (entranceStart !== -1) {\r\n\t\t\t\t\tif (i - entranceStart >= 6) {\r\n\t\t\t\t\t\tthis.addEdge(area, other, x + entranceStart, y, x + entranceStart, y - 1);\r\n\t\t\t\t\t\tthis.addEdge(area, other, x + i - 1, y, x + i - 1, y - 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.addEdge(area, other, x + Math.floor((i - 1 + entranceStart) / 2), y, x + Math.floor((i - 1 + entranceStart) / 2), y - 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tentranceStart = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (entranceStart !== -1) {\r\n\t\t\t\tif (this.AREA_SIZE - entranceStart >= 6) {\r\n\t\t\t\t\tthis.addEdge(area, other, x + entranceStart, y, x + entranceStart, y - 1);\r\n\t\t\t\t\tthis.addEdge(area, other, x + this.AREA_SIZE - 1, y, x + this.AREA_SIZE - 1, y - 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.addEdge(area, other, x + Math.floor((this.AREA_SIZE - 1 + entranceStart) / 2), y, x + Math.floor((this.AREA_SIZE - 1 + entranceStart) / 2), y - 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (area.y - otherY === 0) {\r\n\t\t\tfor (let i = 0; i < this.AREA_SIZE; i++) {\r\n\t\t\t\tif (y + i < gameMap.height && map[x + (y + i) * gameMap.width] === allowed && map[x + (y + i) * gameMap.width - 1] === allowed) {\r\n\t\t\t\t\tif (entranceStart === -1) {\r\n\t\t\t\t\t\tentranceStart = i;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (entranceStart !== -1) {\r\n\t\t\t\t\tif (i - entranceStart >= 6) {\r\n\t\t\t\t\t\tthis.addEdge(area, other, x, y + entranceStart, x - 1, y + entranceStart);\r\n\t\t\t\t\t\tthis.addEdge(area, other, x, y + i - 1, x - 1, y + i - 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.addEdge(area, other, x, y + Math.floor((i - 1 + entranceStart) / 2), x - 1, y + Math.floor((i - 1 + entranceStart) / 2));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tentranceStart = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (entranceStart !== -1) {\r\n\t\t\t\tif (this.AREA_SIZE - entranceStart >= 6) {\r\n\t\t\t\t\tthis.addEdge(area, other, x, y + entranceStart, x - 1, y + entranceStart);\r\n\t\t\t\t\tthis.addEdge(area, other, x, y + this.AREA_SIZE - 1, x - 1, y + this.AREA_SIZE - 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.addEdge(area, other, x, y + Math.floor((this.AREA_SIZE - 1 + entranceStart) / 2), x - 1, y + Math.floor((this.AREA_SIZE - 1 + entranceStart) / 2));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds an edge between two areas.\r\n\t */\r\n\tprivate addEdge(area1: Area, area2: Area, x1: number, y1: number, x2: number, y2: number) {\r\n\t\tconst node1 = this.getOrCreateNode(area1, x1, y1);\r\n\t\tconst node2 = this.getOrCreateNode(area2, x2, y2);\r\n\t\tnode1.edges.push({node: node2, cost: 1, cache: [node2.x + node2.y * gameMap.width]});\r\n\t\tnode2.edges.push({node: node1, cost: 1, cache: [node1.x + node1.y * gameMap.width]});\r\n\t}\r\n\r\n\t/**\r\n\t * Gets or creates a node at a specific position.\r\n\t * @param area The area to get or create the node in.\r\n\t * @param x The x-coordinate of the node.\r\n\t * @param y The y-coordinate of the node.\r\n\t * @returns The node at the position.\r\n\t */\r\n\tprivate getOrCreateNode(area: Area, x: number, y: number): Node {\r\n\t\tfor (const node of area.nodes) {\r\n\t\t\tif (node.x === x && node.y === y) {\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst node = new Node(x, y);\r\n\t\tarea.nodes.push(node);\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates graphs on a per-area basis.\r\n\t */\r\n\tprivate buildAreaGraph(): void {\r\n\t\tfor (const area of this.graph) {\r\n\t\t\tif (this.isAreaEmpty(area)) { //some tiles are just empty, so we can skip them\r\n\t\t\t\tconst id = canonicalAreaId++;\r\n\t\t\t\tthis.nodeIndex[id] = [];\r\n\t\t\t\tfor (let i = 0; i < area.nodes.length; i++) {\r\n\t\t\t\t\tconst node = area.nodes[i];\r\n\t\t\t\t\tnode.canonicalAreaId = id;\r\n\t\t\t\t\tthis.nodeIndex[id].push(node);\r\n\t\t\t\t\tfor (let j = i + 1; j < area.nodes.length; j++) {\r\n\t\t\t\t\t\tconst cost = node.x === area.nodes[j].x || node.y === area.nodes[j].y ? this.AREA_SIZE - 1 : 1.5 * (this.AREA_SIZE - 1);\r\n\t\t\t\t\t\tnode.edges.push({node: area.nodes[j], cost, cache: [area.nodes[j].x + area.nodes[j].y * gameMap.width]});\r\n\t\t\t\t\t\tarea.nodes[j].edges.push({node, cost, cache: [node.x + node.y * gameMap.width]});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (let x = area.x; x < Math.min(area.x + this.AREA_SIZE, gameMap.width); x++) {\r\n\t\t\t\t\tfor (let y = area.y; y < Math.min(area.y + this.AREA_SIZE, gameMap.height * gameMap.width); y++) {\r\n\t\t\t\t\t\tthis.areaIndex[x + y * gameMap.width] = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (let i = 0; i < area.nodes.length; i++) {\r\n\t\t\t\tthis.calculateDistancesRaw(area.nodes[i], area.nodes, area.x, area.y, Math.min(this.AREA_SIZE, gameMap.width - area.x), Math.min(this.AREA_SIZE, gameMap.height - area.y));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the distance starting from one node to others.\r\n\t * Just a simple flood fill.\r\n\t * @param node The node to start from.\r\n\t * @param others The other nodes to calculate the distance to.\r\n\t * @param minX The minimum x-coordinate.\r\n\t * @param minY The minimum y-coordinate.\r\n\t * @param width The width of the area.\r\n\t * @param height The height of the area.\r\n\t */\r\n\tprivate calculateDistancesRaw(node: Node, others: Node[], minX: number, minY: number, width: number, height: number): void {\r\n\t\tconst isSetting = node.canonicalAreaId === undefined;\r\n\t\tif (isSetting) {\r\n\t\t\tnode.canonicalAreaId = canonicalAreaId++;\r\n\t\t\tthis.areaIndex[node.x + node.y * gameMap.width] = node.canonicalAreaId;\r\n\t\t\tthis.nodeIndex[node.canonicalAreaId] = [node];\r\n\t\t}\r\n\t\tconst id = node.canonicalAreaId;\r\n\t\tconst dx = [1, -1, 0, 0, 1, -1, 1, -1], dy = [0, 0, 1, -1, 1, 1, -1, -1];\r\n\t\tconst stack = [node.x - minX, node.y - minY];\r\n\t\tlet stackPointer = 2, queuePointer = 0;\r\n\t\tconst parentMap = new Uint16Array(width * height);\r\n\t\tparentMap[node.x - minX + (node.y - minY) * width] = 1;\r\n\t\twhile (queuePointer < stackPointer) {\r\n\t\t\tconst x = stack[queuePointer++];\r\n\t\t\tconst y = stack[queuePointer++];\r\n\t\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\t\tconst nx = x + dx[i], ny = y + dy[i];\r\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= width || ny >= height || parentMap[nx + ny * width] !== 0 || gameMap.getDistance(nx + minX + (ny + minY) * gameMap.width) >= 0) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (i >= 4 && (gameMap.getDistance(x + minX + (ny + minY) * gameMap.width) >= 0 || gameMap.getDistance(nx + minX + (y + minY) * gameMap.width) >= 0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (isSetting) {\r\n\t\t\t\t\tthis.areaIndex[nx + minX + (ny + minY) * gameMap.width] = id;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparentMap[nx + ny * width] = x + y * width + 2;\r\n\t\t\t\tstack[stackPointer++] = nx;\r\n\t\t\t\tstack[stackPointer++] = ny;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const other of others) {\r\n\t\t\tif (other === node) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst path = [];\r\n\t\t\tlet current = other.x - minX + (other.y - minY) * width;\r\n\t\t\tlet distance = 0;\r\n\t\t\twhile (current >= 0) {\r\n\t\t\t\tpath.push(current % width + minX + (Math.floor(current / width) + minY) * gameMap.width);\r\n\t\t\t\tconst lastX = current % width, lastY = Math.floor(current / width);\r\n\t\t\t\tcurrent = parentMap[current] - 2;\r\n\t\t\t\tdistance += lastX === current % width || lastY === Math.floor(current / width) ? 1 : 1.5;\r\n\t\t\t}\r\n\t\t\tpath.pop();\r\n\t\t\tif (path.length <= 0) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tother.canonicalAreaId = id;\r\n\t\t\tnode.edges.push({node: other, cost: distance + this.AREA_SIZE / 2, cache: path}); //increase cost to prefer open water paths\r\n\t\t\tthis.nodeIndex[id].push(other);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if an area only contains non-solid tiles.\r\n\t * @param area The area to check.\r\n\t * @returns True if the area is empty, false otherwise.\r\n\t */\r\n\tprivate isAreaEmpty(area: Area): boolean {\r\n\t\tconst map = territoryManager.tileOwners;\r\n\t\tconst allowed = territoryManager.OWNER_NONE - 1;\r\n\t\tfor (let y = area.y; y < area.y + this.AREA_SIZE; y++) {\r\n\t\t\tfor (let x = area.x; x < area.x + this.AREA_SIZE; x++) {\r\n\t\t\t\tif (x < gameMap.width && y < gameMap.height && map[x + y * gameMap.width] !== allowed) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nexport const areaCalculator = new AreaCalculator();\r\n\r\nlet canonicalAreaId = 1; //0 is reserved for empty areas\r\n\r\nexport class Area {\r\n\t/**\r\n\t * Warning: These are not the actual coordinates of the area, but the slot in the area grid that the area is in.\r\n\t * Multiple areas can have the same x and y coordinates if they are in the same slot and unreachable from each other.\r\n\t */\r\n\tx: number;\r\n\ty: number;\r\n\tnodes: Node[] = [];\r\n\r\n\tconstructor(x: number, y: number) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n}\r\n\r\nlet currentNodeId = 0;\r\n\r\nexport class Node {\r\n\tx: number;\r\n\ty: number;\r\n\tlevel: number = 0;\r\n\t/** Warning: The cache is reversed and excludes this node */\r\n\tedges: { node: Node, cost: number, cache: number[] }[] = [];\r\n\tid = currentNodeId++;\r\n\tcanonicalAreaId: number;\r\n\r\n\tconstructor(x: number, y: number) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n}","import {gameMap} from \"./Game\";\r\nimport {clientPlayer, playerManager} from \"./player/PlayerManager\";\r\nimport {territoryRenderingManager} from \"../renderer/manager/TerritoryRenderingManager\";\r\nimport {playerNameRenderingManager} from \"../renderer/manager/PlayerNameRenderingManager\";\r\nimport {areaCalculator} from \"../map/area/AreaCalculator\";\r\nimport {onNeighbors} from \"../util/MathUtil\";\r\n\r\nclass TerritoryManager {\r\n\ttileOwners: Uint16Array;\r\n\treadonly OWNER_NONE = 65535;\r\n\tplayerIndex: Uint16Array;\r\n\r\n\t/**\r\n\t * Resets the territory manager.\r\n\t * Should only be called when a new game is started.\r\n\t * @internal\r\n\t */\r\n\treset(): void {\r\n\t\tthis.tileOwners = new Uint16Array(gameMap.width * gameMap.height);\r\n\t\tfor (let i = 0; i < this.tileOwners.length; i++) {\r\n\t\t\tthis.tileOwners[i] = gameMap.getTile(i).isSolid ? this.OWNER_NONE : this.OWNER_NONE - 1;\r\n\t\t}\r\n\r\n\t\tthis.playerIndex = new Uint16Array(areaCalculator.preprocessMap());\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if a tile is a border tile of the territory of its owner.\r\n\t *\r\n\t * A tile is a border tile if it is adjacent to a tile that is not owned by the same player.\r\n\t * Pixels on the edge of the map are also considered border tiles.\r\n\t * @param tile The tile to check.\r\n\t * @returns True if the tile is a border tile, false otherwise.\r\n\t */\r\n\tisBorder(tile: number): boolean {\r\n\t\tconst x = tile % gameMap.width;\r\n\t\tconst y = Math.floor(tile / gameMap.width);\r\n\t\tconst owner = this.tileOwners[tile];\r\n\t\treturn x === 0 || x === gameMap.width - 1 || y === 0 || y === gameMap.height - 1 ||\r\n\t\t\tthis.tileOwners[tile - 1] !== owner || this.tileOwners[tile + 1] !== owner ||\r\n\t\t\tthis.tileOwners[tile - gameMap.width] !== owner || this.tileOwners[tile + gameMap.width] !== owner;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if a tile has an owner.\r\n\t * @param tile The tile to check.\r\n\t * @returns True if the tile has an owner, false otherwise.\r\n\t */\r\n\thasOwner(tile: number): boolean {\r\n\t\treturn this.tileOwners[tile] !== this.OWNER_NONE;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if a tile is owned by a specific player.\r\n\t * @param tile The tile to check.\r\n\t * @param owner The player to check against.\r\n\t * @returns True if the tile is owned by the player, false otherwise.\r\n\t */\r\n\tisOwner(tile: number, owner: number): boolean {\r\n\t\treturn this.tileOwners[tile] === owner;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the owner of a tile.\r\n\t * @param tile The tile to get the owner of.\r\n\t * @returns The owner of the tile.\r\n\t */\r\n\tgetOwner(tile: number): number {\r\n\t\treturn this.tileOwners[tile];\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if a tile is part of a player's territory excluding the player's border.\r\n\t * @param tile The tile to check.\r\n\t * @returns True if the tile is part of a player's territory, false otherwise.\r\n\t */\r\n\tisTerritory(tile: number): boolean {\r\n\t\treturn playerNameRenderingManager.isConsidered(tile);\r\n\t}\r\n\r\n\t/**\r\n\t * Conquers a tile for a player.\r\n\t *\r\n\t * If the tile is already owned by a player, the player will lose the tile.\r\n\t * Conquered tiles will be passed to the renderer directly.\r\n\t * @param tile The tile to conquer.\r\n\t * @param owner The player that will own the tile.\r\n\t */\r\n\tconquer(tile: number, owner: number): void {\r\n\t\tconst previousOwner = this.tileOwners[tile];\r\n\t\tthis.tileOwners[tile] = owner;\r\n\t\tif (previousOwner !== this.OWNER_NONE) {\r\n\t\t\tplayerManager.getPlayer(previousOwner).removeTile(tile);\r\n\t\t\tif (previousOwner === clientPlayer.id) {\r\n\t\t\t\tonNeighbors(tile, (neighbor) => {\r\n\t\t\t\t\tif (!this.isTerritory(neighbor)) {\r\n\t\t\t\t\t\tthis.playerIndex[areaCalculator.areaIndex[neighbor]]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\tplayerManager.getPlayer(owner).addTile(tile);\r\n\t\tif (owner === clientPlayer.id) {\r\n\t\t\tonNeighbors(tile, (neighbor) => {\r\n\t\t\t\tif (!this.isTerritory(neighbor)) {\r\n\t\t\t\t\tthis.playerIndex[areaCalculator.areaIndex[neighbor]]++;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clears a tile.\r\n\t * @see TerritoryManager.conquer\r\n\t * @param tile The tile to clear.\r\n\t */\r\n\tclear(tile: number): void {\r\n\t\tconst owner = this.tileOwners[tile];\r\n\t\tif (owner !== this.OWNER_NONE) {\r\n\t\t\tthis.tileOwners[tile] = this.OWNER_NONE;\r\n\t\t\tplayerManager.getPlayer(owner).removeTile(tile);\r\n\t\t\tterritoryRenderingManager.clear(tile);\r\n\t\t\tif (owner === clientPlayer.id) {\r\n\t\t\t\tonNeighbors(tile, (neighbor) => {\r\n\t\t\t\t\tif (!this.isTerritory(neighbor)) {\r\n\t\t\t\t\t\tthis.playerIndex[areaCalculator.areaIndex[neighbor]]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const territoryManager = new TerritoryManager();","import {gameMap, gameMode} from \"../Game\";\r\nimport {Player} from \"../player/Player\";\r\nimport {mapNavigationHandler} from \"../action/MapNavigationHandler\";\r\nimport {boatManager} from \"./BoatManager\";\r\nimport {territoryManager} from \"../TerritoryManager\";\r\nimport {attackActionHandler} from \"../attack/AttackActionHandler\";\r\nimport {territoryRenderingManager} from \"../../renderer/manager/TerritoryRenderingManager\";\r\nimport {playerNameRenderingManager} from \"../../renderer/manager/PlayerNameRenderingManager\";\r\nimport {playerManager} from \"../player/PlayerManager\";\r\n\r\nexport class Boat {\r\n\tprivate readonly MAX_SPEED = 1;\r\n\r\n\tprivate readonly owner: Player;\r\n\tprivate readonly troops: number;\r\n\tprivate readonly paths: number[][] = [];\r\n\tprivate currentPathIndex: number = 0;\r\n\tprivate currentPath: number[] = [];\r\n\tprivate currentNode: number = 0;\r\n\r\n\tprivate x: number = 0;\r\n\tprivate y: number = 0;\r\n\tprivate nextX: number = 0;\r\n\tprivate nextY: number = 0;\r\n\tprivate speed: number = 0.2;\r\n\tprivate targetSpeed: number = 1;\r\n\r\n\t/**\r\n\t * Creates a new boat with given starting and ending positions.\r\n\t * @param owner The player that owns the boat.\r\n\t * @param path The path to follow.\r\n\t * @param troops The amount of troops the boat carries.\r\n\t */\r\n\tconstructor(owner: Player, path: number[][], troops: number) {\r\n\t\tthis.owner = owner;\r\n\t\tthis.paths = path;\r\n\t\tthis.troops = troops;\r\n\r\n\t\tthis.x = path[0][0] % gameMap.width + 0.5;\r\n\t\tthis.y = Math.floor(path[0][0] / gameMap.width) + 0.5;\r\n\t\tthis.updateWaypoint();\r\n\t}\r\n\r\n\t/**\r\n\t * Moves the boat to the next waypoint.\r\n\t */\r\n\tmove() {\r\n\t\tthis.speed = Math.min(this.MAX_SPEED, this.speed + 0.005, this.targetSpeed + Math.sqrt((this.nextX - this.x) * (this.nextX - this.x) + (this.nextY - this.y) * (this.nextY - this.y)) / 200);\r\n\r\n\t\tlet speed = this.speed;\r\n\t\twhile (speed > 0) {\r\n\t\t\tspeed = this.moveTowards(this.nextX, this.nextY, speed);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Moves the boat towards the given position.\r\n\t * @param x The x-coordinate to move towards.\r\n\t * @param y The y-coordinate to move towards.\r\n\t * @param speed The speed to move with.\r\n\t * @returns The remaining speed.\r\n\t * @private\r\n\t */\r\n\tprivate moveTowards(x: number, y: number, speed: number): number {\r\n\t\tconst dx = x - this.x;\r\n\t\tconst dy = y - this.y;\r\n\t\tconst dist = Math.sqrt(dx * dx + dy * dy);\r\n\t\tif (dist === 0) {\r\n\t\t\t//TODO: how is this even possible?\r\n\t\t\tif (!this.updateWaypoint()) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\treturn speed;\r\n\t\t}\r\n\r\n\t\tif (dist <= speed) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tif (!this.updateWaypoint()) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\treturn speed - dist;\r\n\t\t}\r\n\r\n\t\tthis.x += dx / dist * speed;\r\n\t\tthis.y += dy / dist * speed;\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Initialize the next waypoint.\r\n\t * @returns True if the boat has more waypoints, false otherwise.\r\n\t * @private\r\n\t */\r\n\tprivate updateWaypoint(): boolean {\r\n\t\tconst beforeX = this.nextX, beforeY = this.nextY;\r\n\r\n\t\tif (++this.currentNode < this.currentPath.length) {\r\n\t\t\tthis.nextX = this.currentPath[this.currentNode] % gameMap.width + 0.5;\r\n\t\t\tthis.nextY = Math.floor(this.currentPath[this.currentNode] / gameMap.width) + 0.5;\r\n\t\t} else if (this.currentPathIndex < this.paths.length) {\r\n\t\t\tthis.currentPath = this.paths[this.currentPathIndex++];\r\n\t\t\tthis.currentNode = 0;\r\n\t\t\tthis.nextX = this.currentPath[this.currentNode] % gameMap.width + 0.5;\r\n\t\t\tthis.nextY = Math.floor(this.currentPath[this.currentNode] / gameMap.width) + 0.5;\r\n\t\t} else {\r\n\t\t\t//TODO: find a way to nicely integrate this with the normal attack system (the first tile currently has no cost)\r\n\t\t\t//TODO: if target isn't attackable, return troops to owner\r\n\t\t\tconst target = territoryManager.getOwner(this.currentPath[--this.currentNode]);\r\n\t\t\tif (gameMode.canAttack(this.owner.id, target)) {\r\n\t\t\t\tterritoryManager.conquer(this.currentPath[this.currentNode], this.owner.id);\r\n\t\t\t\tterritoryRenderingManager.applyTransaction(this.owner, playerManager.getPlayer(target) || this.owner);\r\n\t\t\t\tplayerNameRenderingManager.applyTransaction(this.owner, playerManager.getPlayer(target) || this.owner);\r\n\r\n\t\t\t\tif (target === territoryManager.OWNER_NONE) {\r\n\t\t\t\t\tattackActionHandler.attackUnclaimed(this.owner, this.troops, new Set([this.currentPath[this.currentNode]]));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tattackActionHandler.attackPlayer(this.owner, playerManager.getPlayer(target), this.troops, new Set([this.currentPath[this.currentNode]]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tboatManager.unregisterBoat(this);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tthis.targetSpeed = this.calculateSpeed(beforeX, beforeY, this.nextX, this.nextY, 0, 1);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the target speed at the next waypoint.\r\n\t * @param oldX The x-coordinate of the previous waypoint.\r\n\t * @param oldY The y-coordinate of the previous waypoint.\r\n\t * @param currentX The x-coordinate of the current waypoint.\r\n\t * @param currentY The y-coordinate of the current waypoint.\r\n\t * @param dist The distance to the current waypoint.\r\n\t * @param offset The amount of waypoints to skip.\r\n\t * @returns The target speed.\r\n\t * @private\r\n\t */\r\n\tprivate calculateSpeed(oldX: number, oldY: number, currentX: number, currentY: number, dist: number, offset: number): number {\r\n\t\tconst next = this.getWaypoint(offset);\r\n\t\tif (next === -1) {\r\n\t\t\treturn this.MAX_SPEED;\r\n\t\t}\r\n\t\tconst nextX = next % gameMap.width + 0.5, nextY = Math.floor(next / gameMap.width) + 0.5;\r\n\t\tlet angle = Math.atan2(currentY - oldY, currentX - oldX) - Math.atan2(nextY - currentY, nextX - currentX);\r\n\t\tangle = Math.abs((Math.abs(angle) + Math.PI) % (2 * Math.PI) - Math.PI);\r\n\r\n\t\tconst distToNext = dist + Math.sqrt((nextX - currentX) * (nextX - currentX) + (nextY - currentY) * (nextY - currentY));\r\n\r\n\t\tif (distToNext < 100 * this.MAX_SPEED) {\r\n\t\t\treturn Math.min(this.MAX_SPEED * Math.exp(-angle), (distToNext - dist) * 0.005 + this.calculateSpeed(currentX, currentY, nextX, nextY, distToNext, offset + 1));\r\n\t\t}\r\n\t\treturn this.MAX_SPEED * Math.exp(-angle);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the next waypoint in the path.\r\n\t * @param offset The amount of waypoints to skip.\r\n\t * @returns The next waypoint.\r\n\t * @private\r\n\t */\r\n\tprivate getWaypoint(offset: number): number {\r\n\t\tlet currentNode = this.currentNode;\r\n\t\tlet currentPathIndex = this.currentPathIndex - 1;\r\n\t\tfor (let i = 0; i < offset; i++) {\r\n\t\t\tif (++currentNode < this.paths[currentPathIndex].length) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (++currentPathIndex < this.paths.length) {\r\n\t\t\t\tcurrentNode = 0;\r\n\t\t\t} else {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.paths[currentPathIndex][currentNode];\r\n\t}\r\n\r\n\t/**\r\n\t * Renders the boat on the given canvas context.\r\n\t * @param context The canvas context to render on.\r\n\t */\r\n\trender(context: CanvasRenderingContext2D) {\r\n\t\tconst zoom = mapNavigationHandler.zoom;\r\n\t\tconst x = mapNavigationHandler.x;\r\n\t\tconst y = mapNavigationHandler.y;\r\n\r\n\t\t//TODO: Add boat sprite\r\n\t\tcontext.beginPath();\r\n\t\tcontext.arc(this.x * zoom + x, this.y * zoom + y, zoom, 0, 2 * Math.PI);\r\n\t\tcontext.fill();\r\n\t}\r\n}","import {gameMap} from \"../../game/Game\";\r\nimport {PriorityQueue} from \"../../util/PriorityQueue\";\r\nimport {areaCalculator, Node} from \"./AreaCalculator\";\r\nimport {territoryManager} from \"../../game/TerritoryManager\";\r\nimport {clientPlayer} from \"../../game/player/PlayerManager\";\r\nimport {UnsupportedDataException} from \"../../util/exception/UnsupportedDataException\";\r\n\r\n/**\r\n * Pathfinding for boats.\r\n * Hierarchical pathfinding with a single level of abstraction.\r\n * This is heavily adapted to the specific use-case of the game.\r\n */\r\n\r\n/**\r\n * Calculates a list of waypoints between two points.\r\n * @param start The starting position.\r\n * @param end The ending position.\r\n * @returns The path as an array of cached path indices (these combine to form the path).\r\n */\r\nexport function calculateBoatWaypoints(start: number, end: number): number[][] {\r\n\tconst startAreaId = areaCalculator.areaIndex[start];\r\n\tconst startX = start % gameMap.width, startY = Math.floor(start / gameMap.width);\r\n\r\n\tlet inSameArea = false;\r\n\tonNeighborWater(end, tile => {\r\n\t\tif (areaCalculator.areaIndex[tile] === startAreaId) {\r\n\t\t\tinSameArea = true;\r\n\t\t}\r\n\t});\r\n\tif (inSameArea) {\r\n\t\treturn [findPathInArea(start, end), [end]];\r\n\t}\r\n\r\n\tconst queue = new PriorityQueue<[Node, number, number]>((a, b) => a[1] < b[1]);\r\n\tconst costs = [];\r\n\tconst parents: { node: Node, cache: number[] }[] = [];\r\n\tonNeighborWater(end, tile => {\r\n\t\tconst startPoints = findStartsInArea(tile);\r\n\t\tfor (const node of areaCalculator.nodeIndex[areaCalculator.areaIndex[tile]]) {\r\n\t\t\tqueue.push([node, startPoints[(node.x % areaCalculator.AREA_SIZE) + (node.y % areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE] + Math.sqrt((node.x - startX) * (node.x - startX) + (node.y - startY) * (node.y - startY)), startPoints[(node.x % areaCalculator.AREA_SIZE) + (node.y % areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE]]);\r\n\t\t\tcosts[node.id] = 1;\r\n\t\t}\r\n\t});\r\n\twhile (!queue.isEmpty()) {\r\n\t\tconst [node, _, cost] = queue.pop();\r\n\t\tif (node.canonicalAreaId === startAreaId) {\r\n\t\t\tconst path: number[][] = [];\r\n\t\t\tlet current = {node, cache: findPathInArea(start, node.x + node.y * gameMap.width)}, last = current;\r\n\t\t\twhile (current !== undefined) {\r\n\t\t\t\tpath.push(current.cache);\r\n\t\t\t\tlast = current;\r\n\t\t\t\tcurrent = parents[current.node.id];\r\n\t\t\t}\r\n\t\t\tpath.pop();\r\n\t\t\tpath.push(findPathInArea(last.node.x + last.node.y * gameMap.width, end));\r\n\t\t\tpath.push([end]);\r\n\t\t\treturn path;\r\n\t\t}\r\n\t\tfor (const edge of node.edges) {\r\n\t\t\tconst newCost = cost + edge.cost + Math.sqrt((edge.node.x - startX) * (edge.node.x - startX) + (edge.node.y - startY) * (edge.node.y - startY));\r\n\t\t\tif (costs[edge.node.id] && costs[edge.node.id] <= newCost) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (!costs[edge.node.id]) queue.push([edge.node, newCost, cost + edge.cost]);\r\n\t\t\telse queue.update(element => element[0] === edge.node, [edge.node, newCost, cost + edge.cost]);\r\n\t\t\tcosts[edge.node.id] = newCost;\r\n\t\t\tparents[edge.node.id] = {node, cache: edge.cache};\r\n\t\t}\r\n\t}\r\n\treturn [];\r\n}\r\n\r\n/**\r\n * Finds a path between two points in the same area.\r\n * @param start The starting position.\r\n * @param end The ending position.\r\n * @returns The path from start to end.\r\n */\r\nfunction findPathInArea(start: number, end: number) {\r\n\tconst minX = Math.floor((end % gameMap.width) / areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE;\r\n\tconst minY = Math.floor(Math.floor(end / gameMap.width) / areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE;\r\n\tconst width = Math.min(gameMap.width - minX, areaCalculator.AREA_SIZE);\r\n\tconst height = Math.min(gameMap.height - minY, areaCalculator.AREA_SIZE);\r\n\tconst startX = start % gameMap.width - minX, startY = Math.floor(start / gameMap.width) - minY;\r\n\tconst dx = [0, 1, 0, -1, 1, 1, -1, -1], dy = [-1, 0, 1, 0, -1, 1, 1, -1];\r\n\tconst queue = new PriorityQueue<[number, number, number]>((a, b) => a[2] < b[2]);\r\n\tconst costMap = new Uint16Array(width * height);\r\n\tconst parentMap = new Uint16Array(width * height);\r\n\tonNeighborWater(end, tile => {\r\n\t\tqueue.push([tile % gameMap.width - minX, Math.floor(tile / gameMap.width) - minY, 0]);\r\n\t\tcostMap[tile % gameMap.width - minX + (Math.floor(tile / gameMap.width) - minY) * width] = 1;\r\n\t\tparentMap[tile % gameMap.width - minX + (Math.floor(tile / gameMap.width) - minY) * width] = 1;\r\n\t});\r\n\twhile (!queue.isEmpty()) {\r\n\t\tconst [x, y, cost] = queue.pop();\r\n\t\tif (x === startX && y === startY) {\r\n\t\t\tconst path = [];\r\n\t\t\tlet current = startX + startY * width;\r\n\t\t\twhile (current >= 0) {\r\n\t\t\t\tpath.push(current % width + minX + (Math.floor(current / width) + minY) * gameMap.width);\r\n\t\t\t\tcurrent = parentMap[current] - 2;\r\n\t\t\t}\r\n\t\t\tif (path.length !== 1) path.pop();\r\n\t\t\treturn path;\r\n\t\t}\r\n\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\tconst nx = x + dx[i], ny = y + dy[i];\r\n\t\t\tif (nx < 0 || ny < 0 || nx >= width || ny >= height || gameMap.getDistance(nx + minX + (ny + minY) * gameMap.width) >= 0) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst newCost = cost + 1 + Math.sqrt((nx - startX) * (nx - startX) + (ny - startY) * (ny - startY));\r\n\t\t\tif (costMap[nx + ny * width] && costMap[nx + ny * width] <= newCost) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (i >= 4 && (gameMap.getDistance(x + minX + (ny + minY) * gameMap.width) >= 0 || gameMap.getDistance(nx + minX + (y + minY) * gameMap.width) >= 0)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tqueue.push([nx, ny, newCost]);\r\n\t\t\tcostMap[nx + ny * width] = newCost;\r\n\t\t\tparentMap[nx + ny * width] = x + y * width + 2;\r\n\t\t}\r\n\t}\r\n\treturn [];\r\n}\r\n\r\n/**\r\n * Finds costs for all nodes in the area.\r\n * Note: costs are 1-based, 0 means the node cannot be reached.\r\n * @param start The starting position.\r\n * @returns costs for all nodes in the area.\r\n */\r\nfunction findStartsInArea(start: number) {\r\n\tconst minX = Math.floor((start % gameMap.width) / areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE;\r\n\tconst minY = Math.floor(Math.floor(start / gameMap.width) / areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE;\r\n\tconst height = Math.min(gameMap.height - minY, areaCalculator.AREA_SIZE);\r\n\tconst dx = [0, 1, 0, -1, 1, 1, -1, -1], dy = [-1, 0, 1, 0, -1, 1, 1, -1];\r\n\tconst stack = [start % gameMap.width - minX, Math.floor(start / gameMap.width) - minY];\r\n\tlet stackPointer = 2, queuePointer = 0;\r\n\tconst distanceMap = new Uint16Array(areaCalculator.AREA_SIZE * height);\r\n\tdistanceMap[start % gameMap.width - minX + (Math.floor(start / gameMap.width) - minY) * areaCalculator.AREA_SIZE] = 1;\r\n\twhile (queuePointer < stackPointer) {\r\n\t\tconst x = stack[queuePointer++];\r\n\t\tconst y = stack[queuePointer++];\r\n\t\tconst distance = distanceMap[x + y * areaCalculator.AREA_SIZE];\r\n\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\tconst nx = x + dx[i], ny = y + dy[i];\r\n\t\t\tif (nx < 0 || ny < 0 || nx >= areaCalculator.AREA_SIZE || ny >= height || distanceMap[nx + ny * areaCalculator.AREA_SIZE] !== 0 || gameMap.getDistance(nx + minX + (ny + minY) * gameMap.width) >= 0) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (i >= 4 && (gameMap.getDistance(x + minX + (ny + minY) * gameMap.width) >= 0 || gameMap.getDistance(nx + minX + (y + minY) * gameMap.width) >= 0)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tdistanceMap[nx + ny * areaCalculator.AREA_SIZE] = distance + 1;\r\n\t\t\tstack[stackPointer++] = nx;\r\n\t\t\tstack[stackPointer++] = ny;\r\n\t\t}\r\n\t}\r\n\treturn distanceMap;\r\n}\r\n\r\n/**\r\n * Finds a suitable starting point for the pathfinding.\r\n * Warning: This only works for the local player.\r\n * @param target The target position.\r\n * @returns The starting point for the pathfinding or null if none is found.\r\n */\r\nexport function findStartingPoint(target: number): number | null {\r\n\tlet inSameArea = false;\r\n\tonNeighborWater(target, tile => {\r\n\t\tif (territoryManager.playerIndex[areaCalculator.areaIndex[tile]] > 0) {\r\n\t\t\tinSameArea = true;\r\n\t\t}\r\n\t});\r\n\tif (inSameArea) {\r\n\t\treturn findPlayerTile(target)[0];\r\n\t}\r\n\r\n\tconst queue = new PriorityQueue<[Node, number]>((a, b) => a[1] < b[1]);\r\n\tconst costs = [];\r\n\tonNeighborWater(target, tile => {\r\n\t\tconst startPoints = findStartsInArea(tile);\r\n\t\tfor (const node of areaCalculator.nodeIndex[areaCalculator.areaIndex[tile]]) {\r\n\t\t\tqueue.push([node, startPoints[(node.x % areaCalculator.AREA_SIZE) + (node.y % areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE]]);\r\n\t\t\tcosts[node.id] = startPoints[(node.x % areaCalculator.AREA_SIZE) + (node.y % areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE];\r\n\t\t}\r\n\t});\r\n\tlet found = null, foundCost = Infinity;\r\n\twhile (!queue.isEmpty()) {\r\n\t\tconst [node, cost] = queue.pop();\r\n\t\tif (cost >= foundCost) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (territoryManager.playerIndex[node.canonicalAreaId] > 0) {\r\n\t\t\tconst [tile, distance] = findPlayerTile(node.x + node.y * gameMap.width);\r\n\t\t\tif (distance < foundCost) {\r\n\t\t\t\tfound = tile;\r\n\t\t\t\tfoundCost = distance;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const edge of node.edges) {\r\n\t\t\tconst newCost = cost + edge.cost;\r\n\t\t\tif (costs[edge.node.id] && costs[edge.node.id] <= newCost) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tqueue.push([edge.node, newCost]);\r\n\t\t\tcosts[edge.node.id] = newCost;\r\n\t\t}\r\n\t}\r\n\treturn found;\r\n}\r\n\r\n/**\r\n * Finds the closest water tile allowing creation of a boat.\r\n * The territory tile bordering the tile in question does not have to be in the same area.\r\n * @param start The starting position.\r\n * @returns The closest water tile and the distance to it.\r\n * @throws UnsupportedDataException if no suitable tile is found. This should never happen.\r\n */\r\nfunction findPlayerTile(start: number): [number, number] {\r\n\tconst minX = Math.floor((start % gameMap.width) / areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE;\r\n\tconst minY = Math.floor(Math.floor(start / gameMap.width) / areaCalculator.AREA_SIZE) * areaCalculator.AREA_SIZE;\r\n\tconst height = Math.min(gameMap.height - minY, areaCalculator.AREA_SIZE), width = Math.min(gameMap.width - minX, areaCalculator.AREA_SIZE);\r\n\tconst dx = [0, 1, 0, -1, 1, 1, -1, -1], dy = [-1, 0, 1, 0, -1, 1, 1, -1];\r\n\tconst stack = [(start % gameMap.width) - minX, Math.floor(start / gameMap.width) - minY];\r\n\tlet stackPointer = 2, queuePointer = 0;\r\n\tconst distanceMap = new Uint16Array(width * height);\r\n\tdistanceMap[(start % gameMap.width) - minX + Math.floor(start / gameMap.width) * width] = 1;\r\n\twhile (queuePointer < stackPointer) {\r\n\t\tconst x = stack[queuePointer++];\r\n\t\tconst y = stack[queuePointer++];\r\n\t\tconst distance = distanceMap[x + y * width];\r\n\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\tconst nx = x + dx[i], ny = y + dy[i];\r\n\t\t\tif (i <= 4 && territoryManager.isOwner(nx + minX + (ny + minY) * gameMap.width, clientPlayer.id)) {\r\n\t\t\t\treturn [x + minX + (y + minY) * gameMap.width, distance];\r\n\t\t\t}\r\n\t\t\tif (nx < 0 || ny < 0 || nx >= width || ny >= height || distanceMap[nx + ny * width] !== 0 || gameMap.getDistance(nx + minX + (ny + minY) * gameMap.width) >= 0) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (i >= 4 && (gameMap.getDistance(x + minX + (ny + minY) * gameMap.width) >= 0 || gameMap.getDistance(nx + minX + (y + minY) * gameMap.width) >= 0)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tdistanceMap[nx + ny * width] = distance + 1;\r\n\t\t\tstack[stackPointer++] = nx;\r\n\t\t\tstack[stackPointer++] = ny;\r\n\t\t}\r\n\t}\r\n\tthrow new UnsupportedDataException(\"No suitable tile found\");\r\n}\r\n\r\n/**\r\n * Calls the closure for all water tiles neighboring the given tile (including the tile itself).\r\n * @param tile The tile to check.\r\n * @param closure The closure to call.\r\n */\r\nfunction onNeighborWater(tile: number, closure: (tile: number) => void) {\r\n\tconst x = tile % gameMap.width, y = Math.floor(tile / gameMap.width);\r\n\tfor (let i = 0; i < 5; i++) {\r\n\t\tconst checkX = x + [0, 0, 0, -1, 1][i];\r\n\t\tconst checkY = y + [-1, 1, 0, 0, 0][i];\r\n\t\tif (checkX < 0 || checkY < 0 || checkX >= gameMap.width || checkY >= gameMap.height || gameMap.getDistance(checkX + checkY * gameMap.width) >= 0) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tclosure(checkX + checkY * gameMap.width);\r\n\t}\r\n}","import {Boat} from \"./Boat\";\r\nimport {clientPlayer, playerManager} from \"../player/PlayerManager\";\r\nimport {calculateBoatWaypoints, findStartingPoint} from \"../../map/area/BoatPathfinding\";\r\nimport {gameTicker} from \"../GameTicker\";\r\nimport {gameMap} from \"../Game\";\r\n\r\nclass BoatManager {\r\n\tprivate readonly boats: Boat[] = [];\r\n\r\n\treset(): void {\r\n\t\tthis.boats.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Requests a new boat for the local player.\r\n\t * @param target The target position.\r\n\t * @param percentage The percentage of the player's troops to send.\r\n\t */\r\n\trequestBoat(target: number, percentage: number): void {\r\n\t\tconst coast = this.findCoastNear(target);\r\n\t\tif (coast === null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst start = findStartingPoint(coast);\r\n\r\n\t\tif (start !== null) {\r\n\t\t\tthis.addBoat(clientPlayer.id, start, coast, percentage);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finds a tile bordering water near the given tile (5x5 area).\r\n\t * @param tile The tile to find water near.\r\n\t * @returns The water tile or null if no water is found\r\n\t */\r\n\tprivate findCoastNear(tile: number): number | null {\r\n\t\tconst x = tile % gameMap.width;\r\n\t\tconst y = Math.floor(tile / gameMap.width);\r\n\r\n\t\tfor (let i = 0; i < 10; i++) {\r\n\t\t\tconst sign = i % 2 === 0 ? -1 : 1;\r\n\t\t\tconst ny = y + Math.ceil(i / 2) * sign;\r\n\t\t\tif (ny >= 0 && ny < gameMap.height) {\r\n\t\t\t\tfor (let j = -Math.ceil(i / 2); j <= Math.floor(i / 2); j++) {\r\n\t\t\t\t\tconst nx = x + j * sign;\r\n\t\t\t\t\tif (nx >= 0 && nx < gameMap.width && gameMap.getDistance(nx + ny * gameMap.width) === 0) {\r\n\t\t\t\t\t\treturn nx + ny * gameMap.width;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tconst nx = x + (Math.floor(i / 2) + 1) * sign;\r\n\t\t\tif (nx >= 0 && nx < gameMap.width) {\r\n\t\t\t\tfor (let j = -Math.floor(i / 2); j <= Math.ceil(i / 2); j++) {\r\n\t\t\t\t\tconst ny = y + j * sign;\r\n\t\t\t\t\tif (ny >= 0 && ny < gameMap.height && gameMap.getDistance(nx + ny * gameMap.width) === 0) {\r\n\t\t\t\t\t\treturn nx + ny * gameMap.width;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a boat to the boat manager.\r\n\t * @param owner The owner of the boat.\r\n\t * @param start The starting position of the boat.\r\n\t * @param end The ending position of the boat.\r\n\t * @param percentage The percentage of the owner's troops to send.\r\n\t */\r\n\taddBoat(owner: number, start: number, end: number, percentage: number): void {\r\n\t\tconst path = calculateBoatWaypoints(start, end).filter(piece => piece.length > 0);\r\n\r\n\t\tif (path.length > 0) {\r\n\t\t\t//TODO: boats need a hefty tax (scaling with distance and player strength)\r\n\t\t\tconst player = playerManager.getPlayer(owner);\r\n\t\t\tconst troops = Math.floor(player.getTroops() * percentage);\r\n\t\t\tplayer.removeTroops(troops);\r\n\r\n\t\t\tthis.boats.push(new Boat(playerManager.getPlayer(owner), path, troops));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a boat from the boat manager.\r\n\t * @param boat The boat to remove.\r\n\t */\r\n\tunregisterBoat(boat: Boat): void {\r\n\t\tconst index = this.boats.indexOf(boat);\r\n\t\tif (index !== -1) {\r\n\t\t\tthis.boats.splice(index, 1);\r\n\t\t}\r\n\t}\r\n\r\n\ttick(this: void): void {\r\n\t\tfor (const boat of boatManager.boats) {\r\n\t\t\tboat.move();\r\n\t\t}\r\n\t}\r\n\r\n\trender(context: CanvasRenderingContext2D) {\r\n\t\tfor (const boat of this.boats) {\r\n\t\t\tboat.render(context);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const boatManager = new BoatManager();\r\n\r\ngameTicker.registry.register(boatManager.tick);","import {ClickEventListener, interactionManager} from \"../../event/InteractionManager\";\r\nimport {mapNavigationHandler} from \"./MapNavigationHandler\";\r\nimport {clientPlayer} from \"../player/PlayerManager\";\r\nimport {spawnManager} from \"../player/SpawnManager\";\r\nimport {boatManager} from \"../boat/BoatManager\";\r\nimport {attackActionHandler} from \"../attack/AttackActionHandler\";\r\nimport {territoryManager} from \"../TerritoryManager\";\r\n\r\n/**\r\n * Default map click action handler.\r\n * Executes the selected action on the clicked tile.\r\n */\r\nclass MapActionHandler implements ClickEventListener {\r\n\tprivate action: (tile: number) => void;\r\n\r\n\t/**\r\n\t * Enables the map action handler.\r\n\t */\r\n\tenable() {\r\n\t\tthis.setAction(tile => spawnManager.isSelecting ? spawnManager.selectSpawnPoint(clientPlayer, tile) : attackActionHandler.hasBorderWith(clientPlayer, territoryManager.getOwner(tile)) ? attackActionHandler.preprocessAttack(clientPlayer.id, territoryManager.getOwner(tile), 0.2) : boatManager.requestBoat(tile, 0.2));\r\n\t\tinteractionManager.click.register(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Disables the map action handler.\r\n\t */\r\n\tdisable() {\r\n\t\tinteractionManager.click.unregister(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Set the action to execute on a tile click.\r\n\t * @param action The action to execute.\r\n\t */\r\n\tsetAction(action: (tile: number) => void) {\r\n\t\tthis.action = action;\r\n\t}\r\n\r\n\tonClick(x: number, y: number): void {\r\n\t\tthis.action(mapNavigationHandler.getIndex(x, y));\r\n\t}\r\n\r\n\ttest(x: number, y: number): boolean {\r\n\t\treturn mapNavigationHandler.isOnMap(x, y);\r\n\t}\r\n}\r\n\r\nexport const mapActionHandler = new MapActionHandler();","import {PostGenerationShader} from \"./PostGenerationShader\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\nimport {gameMap} from \"../../game/Game\";\r\nimport {RGBColor} from \"../../util/RGBColor\";\r\n\r\n/**\r\n * Shader affecting all tiles withing a fixed distance range.\r\n * Other than {@link DynamicDistanceShader}, this shader always uses the same color.\r\n */\r\nexport class FixedDistanceShader implements PostGenerationShader {\r\n\tprivate readonly color: RGBColor;\r\n\tprivate readonly min: number;\r\n\tprivate readonly max: number;\r\n\r\n\t/**\r\n\t * Create a new territory outline shader.\r\n\t * @param color the color of the outline.\r\n\t * @param min the minimum distance (inclusive).\r\n\t * @param max the maximum distance (exclusive).\r\n\t */\r\n\tconstructor(color: HSLColor, min: number, max: number) {\r\n\t\tthis.color = color.toRGB();\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\t}\r\n\r\n\tapply(pixels: Uint8ClampedArray): void {\r\n\t\tconst map = gameMap.distanceMap;\r\n\t\tfor (let i = 0; i < map.length; i++) {\r\n\t\t\tif (map[i] < this.max && map[i] >= this.min) {\r\n\t\t\t\tthis.color.blendWithBuffer(pixels, i * 4);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","import {PostGenerationShader} from \"./PostGenerationShader\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\nimport {gameMap} from \"../../game/Game\";\r\nimport {RGBColor} from \"../../util/RGBColor\";\r\n\r\n/**\r\n * Shader affecting all tiles withing a fixed distance range.\r\n * Other than {@link FixedDistanceShader}, this shader decreases color intensity with distance.\r\n */\r\nexport class DynamicDistanceShader implements PostGenerationShader {\r\n\tprivate readonly color: RGBColor;\r\n\tprivate readonly min: number;\r\n\tprivate readonly max: number;\r\n\tprivate readonly gradient: number;\r\n\r\n\t/**\r\n\t * Create a new territory outline shader.\r\n\t * @param color the color of the outline.\r\n\t * @param min the minimum distance (inclusive).\r\n\t * @param max the maximum distance (exclusive).\r\n\t * @param gradient the gradient of the color decrease (higher values decrease color intensity faster, sign determines direction).\r\n\t */\r\n\tconstructor(color: HSLColor, min: number, max: number, gradient: number) {\r\n\t\tthis.color = color.toRGB();\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\t\tthis.gradient = gradient;\r\n\t}\r\n\r\n\tapply(pixels: Uint8ClampedArray): void {\r\n\t\tconst map = gameMap.distanceMap;\r\n\t\tfor (let i = 0; i < map.length; i++) {\r\n\t\t\tif (map[i] < this.max && map[i] >= this.min) {\r\n\t\t\t\tthis.color.blendWithBuffer(pixels, i * 4, this.gradient > 0 ? this.gradient * (map[i] - this.min) : 1 + this.gradient * (map[i] - this.min));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","import {PostGenerationShader} from \"./PostGenerationShader\";\r\nimport {getSetting} from \"../../util/UserSettingManager\";\r\nimport {FixedDistanceShader} from \"./FixedDistanceShader\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\nimport {DynamicDistanceShader} from \"./DynamicDistanceShader\";\r\n\r\nconst shaderList = {\r\n\t\"territory-outline\": {type: \"post-generation\", build: (args: { color: HSLColor, thickness: number }) => new FixedDistanceShader(args.color, -args.thickness, 0)},\r\n\t\"territory-inline\": {type: \"post-generation\", build: (args: { color: HSLColor, thickness: number }) => new FixedDistanceShader(args.color, 0, args.thickness)},\r\n\t\"territory-outline-smooth\": {type: \"post-generation\", build: (args: { color: HSLColor, thickness: number }) => new DynamicDistanceShader(args.color, -args.thickness, 0, 1 / args.thickness)},\r\n\t\"territory-inline-smooth\": {type: \"post-generation\", build: (args: { color: HSLColor, thickness: number }) => new DynamicDistanceShader(args.color, 0, args.thickness, -1 / args.thickness)},\r\n\t\"fixed-distance\": {type: \"post-generation\", build: (args: { color: HSLColor, min: number, max: number }) => new FixedDistanceShader(args.color, args.min, args.max)},\r\n\t\"dynamic-distance\": {type: \"post-generation\", build: (args: { color: HSLColor, min: number, max: number, gradient: number }) => new DynamicDistanceShader(args.color, args.min, args.max, args.gradient)}\r\n} as Record<string, {type: \"post-generation\", build: (args: unknown) => PostGenerationShader}>;\r\nconst activePostGeneration: PostGenerationShader[] = [];\r\n\r\n/**\r\n * Load all shaders from the current theme.\r\n */\r\nexport function loadShaders(): void {\r\n\tfor (const shaderData of getSetting(\"theme\").getShaderArgs()) {\r\n\t\tconst shader = shaderList[shaderData.name];\r\n\t\tif (!shader) {\r\n\t\t\tconsole.error(`Unknown shader: ${shaderData.name}`);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tconst obj = shader.build(shaderData.args);\r\n\t\tif (shader.type === \"post-generation\") {\r\n\t\t\taddPostGenerationShader(obj);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Add a post-generation shader to the list of active shaders.\r\n * @param shader The shader to add.\r\n */\r\nexport function addPostGenerationShader(shader: PostGenerationShader): void {\r\n\tactivePostGeneration.push(shader);\r\n}\r\n\r\n/**\r\n * Apply all active post-generation shaders to the map.\r\n * @param pixels The pixel data of the map.\r\n * @internal\r\n */\r\nexport function applyPostGenerationShaders(pixels: Uint8ClampedArray): void {\r\n\tfor (const shader of activePostGeneration) {\r\n\t\tshader.apply(pixels);\r\n\t}\r\n}","import {CachedLayer} from \"./CachedLayer\";\r\nimport {gameMap, isPlaying} from \"../../game/Game\";\r\nimport {mapTransformHandler} from \"../../event/MapTransformHandler\";\r\nimport {getSetting, registerSettingListener} from \"../../util/UserSettingManager\";\r\nimport {GameTheme} from \"../GameTheme\";\r\nimport {applyPostGenerationShaders, loadShaders} from \"../shader/ShaderManager\";\r\nimport {RGBColor} from \"../../util/RGBColor\";\r\n\r\n/**\r\n * Map background renderer.\r\n * All static map tiles (and possibly other static objects) should be rendered here.\r\n * @internal\r\n */\r\nclass MapRenderer extends CachedLayer {\r\n\tinvalidateCaches(): void {\r\n\t\tthis.resizeCanvas(gameMap.width, gameMap.height);\r\n\t\tloadShaders();\r\n\t\tthis.forceRepaint(getSetting(\"theme\"));\r\n\t}\r\n\r\n\tforceRepaint(theme: GameTheme): void {\r\n\t\tconst imageData = this.context.getImageData(0, 0, gameMap.width, gameMap.height);\r\n\t\tconst tileColors: RGBColor[] = [];\r\n\t\tfor (let i = 0; i < gameMap.width * gameMap.height; i++) {\r\n\t\t\tconst tile = gameMap.getTile(i);\r\n\t\t\tif (!tileColors[tile.id]) {\r\n\t\t\t\ttileColors[tile.id] = theme.getTileColor(tile).toRGB();\r\n\t\t\t}\r\n\t\t\ttileColors[tile.id].writeToBuffer(imageData.data, i * 4);\r\n\t\t}\r\n\t\tapplyPostGenerationShaders(imageData.data);\r\n\t\tthis.context.putImageData(imageData, 0, 0);\r\n\t}\r\n\r\n\tonMapMove(this: void, x: number, y: number): void {\r\n\t\tmapRenderer.dx = x;\r\n\t\tmapRenderer.dy = y;\r\n\t}\r\n\r\n\tonMapScale(this: void, scale: number): void {\r\n\t\tmapRenderer.scale = scale;\r\n\t}\r\n}\r\n\r\nexport const mapRenderer = new MapRenderer();\r\n\r\nmapTransformHandler.scale.register(mapRenderer.onMapScale);\r\nmapTransformHandler.move.register(mapRenderer.onMapMove);\r\n\r\nregisterSettingListener(\"theme\", (theme) => isPlaying && mapRenderer.forceRepaint(theme));","import {EventHandlerRegistry} from \"./EventHandlerRegistry\";\r\n\r\n/**\r\n * Registry for window resize listeners.\r\n * Window resize listeners are called when the window is resized.\r\n *\r\n * Format: (width: number, height: number) => void\r\n * @param width The new width of the window in pixels.\r\n * @param height The new height of the window in pixels.\r\n */\r\nexport const windowResizeHandler: EventHandlerRegistry<[number, number]> = new EventHandlerRegistry(true, listener => listener(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio));\r\nwindow.addEventListener(\"resize\", () => windowResizeHandler.broadcast());","import {RendererLayer} from \"./RendererLayer\";\r\nimport {getSetting} from \"../../util/UserSettingManager\";\r\n\r\n/**\r\n * A simple background layer that fills the canvas with a color.\r\n * This also clears any previous content on the canvas, so transparent layers don't leave artifacts.\r\n */\r\nclass BackgroundLayer implements RendererLayer {\r\n\trender(context: CanvasRenderingContext2D): void {\r\n\t\tcontext.fillStyle = getSetting(\"theme\").getBackgroundColor().toString();\r\n\t\tcontext.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n\t}\r\n}\r\n\r\nexport const backgroundLayer = new BackgroundLayer();","import {RendererLayer} from \"./RendererLayer\";\r\nimport {playerNameRenderingManager} from \"../manager/PlayerNameRenderingManager\";\r\nimport {playerManager} from \"../../game/player/PlayerManager\";\r\nimport {mapNavigationHandler} from \"../../game/action/MapNavigationHandler\";\r\n\r\nclass NameRenderer implements RendererLayer {\r\n\trender(context: CanvasRenderingContext2D): void {\r\n\t\tcontext.textRendering = \"optimizeSpeed\";\r\n\t\tcontext.textAlign = \"center\";\r\n\t\tconst xMin = mapNavigationHandler.getMapX(0);\r\n\t\tconst xMax = mapNavigationHandler.getMapX(context.canvas.width);\r\n\t\tconst yMin = mapNavigationHandler.getMapY(0);\r\n\t\tconst yMax = mapNavigationHandler.getMapY(context.canvas.height);\r\n\t\tfor (let i = 0; i < playerNameRenderingManager.playerData.length; i++) {\r\n\t\t\tconst player = playerManager.getPlayer(i);\r\n\t\t\tif (player && player.isAlive()) {\r\n\t\t\t\tconst data = playerNameRenderingManager.playerData[i];\r\n\t\t\t\tif (data.size * mapNavigationHandler.zoom < 1 || data.nameX + 1 < xMin || data.nameX - data.size + 1 > xMax || data.nameY + 1 < yMin || data.nameY - data.size + 1 > yMax) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tdata.renderPlayer(context, player);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const nameRenderer = new NameRenderer();","import {RendererLayer} from \"./RendererLayer\";\r\nimport {boatManager} from \"../../game/boat/BoatManager\";\r\n\r\nclass BoatRenderer implements RendererLayer {\r\n\trender(context: CanvasRenderingContext2D): void {\r\n\t\tboatManager.render(context);\r\n\t}\r\n}\r\n\r\nexport const boatRenderer = new BoatRenderer();","import {RendererLayer} from \"./layer/RendererLayer\";\r\nimport {mapRenderer} from \"./layer/MapRenderer\";\r\nimport {windowResizeHandler} from \"../event/WindowResizeHandler\";\r\nimport {backgroundLayer} from \"./layer/BackgroundLayer\";\r\nimport {territoryRenderer} from \"./layer/TerritoryRenderer\";\r\nimport {nameRenderer} from \"./layer/NameRenderer\";\r\nimport {boatRenderer} from \"./layer/BoatRenderer\";\r\n\r\n/**\r\n * Main renderer for anything canvas related in the game.\r\n * Paints images on multiple layers (in order) to the canvas.\r\n * @internal\r\n */\r\nexport class GameRenderer {\r\n\tprivate readonly canvas: HTMLCanvasElement;\r\n\tprivate readonly context: CanvasRenderingContext2D;\r\n\tprivate layers: RendererLayer[] = [];\r\n\r\n\tconstructor() {\r\n\t\tthis.canvas = document.createElement(\"canvas\");\r\n\t\tthis.canvas.style.position = \"absolute\";\r\n\t\tthis.canvas.style.left = \"0\";\r\n\t\tthis.canvas.style.top = \"0\";\r\n\t\tthis.canvas.style.zIndex = \"-1\";\r\n\t\tthis.context = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n\t\tthis.doRenderTick();\r\n\r\n\t\tdocument.body.appendChild(this.canvas);\r\n\t}\r\n\r\n\t/**\r\n\t * Register necessary layers for in-game rendering.\r\n\t * @internal\r\n\t */\r\n\tinitGameplayLayers(): void {\r\n\t\tthis.layers = [];\r\n\t\tthis.registerLayer(backgroundLayer);\r\n\t\tthis.registerLayer(mapRenderer);\r\n\t\tthis.registerLayer(territoryRenderer);\r\n\t\tthis.registerLayer(nameRenderer);\r\n\t\tthis.registerLayer(boatRenderer);\r\n\t}\r\n\r\n\t/**\r\n\t * Register a new layer to be rendered.\r\n\t *\r\n\t * This renderer will be rendered on top of all other layers.\r\n\t * Note that you will have to re-register every time the renderer is changed (e.g. when a game is started).\r\n\t *\r\n\t * @param layer the layer to be rendered.\r\n\t */\r\n\tregisterLayer(layer: RendererLayer): void {\r\n\t\tlayer.invalidateCaches?.();\r\n\t\tthis.layers.push(layer);\r\n\t}\r\n\r\n\t/**\r\n\t * Tick layers and render them to the canvas.\r\n\t */\r\n\tprivate doRenderTick(): void {\r\n\t\tthis.context.imageSmoothingEnabled = false;\r\n\t\tthis.layers.forEach(layer => {\r\n\t\t\tlayer.render(this.context);\r\n\t\t});\r\n\t\trequestAnimationFrame(() => this.doRenderTick());\r\n\t}\r\n\r\n\tresize(this: void, width: number, height: number): void {\r\n\t\tgameRenderer.canvas.width = Math.ceil(width / window.devicePixelRatio);\r\n\t\tgameRenderer.canvas.height = Math.ceil(height / window.devicePixelRatio);\r\n\t}\r\n}\r\n\r\nexport const gameRenderer = new GameRenderer();\r\n\r\nwindowResizeHandler.register(gameRenderer.resize);","import {RawMapData} from \"../../MapCodec\";\r\n\r\nexport class ZoneCalculator {\r\n\t/**\r\n\t * Builds zones from a map\r\n\t * @param data raw map data\r\n\t * @returns array of zones\r\n\t */\r\n\tstatic buildZones(data: RawMapData): TileZone[] {\r\n\t\tconst result: TileZone[] = [];\r\n\t\tfor (const zone of ZoneCalculator.calculateZones(data)) {\r\n\t\t\tconst tileMap: boolean[] = [];\r\n\t\t\tfor (const tile of zone) {\r\n\t\t\t\ttileMap[tile] = true;\r\n\t\t\t}\r\n\r\n\t\t\tconst leftBorder = [];\r\n\t\t\tconst leftBorderMap = [];\r\n\t\t\tconst topBorder = [];\r\n\t\t\tconst topBorderMap = [];\r\n\t\t\tfor (const tile of zone) {\r\n\t\t\t\tif (!tileMap[tile - 1]) {\r\n\t\t\t\t\tleftBorder.push(tile);\r\n\t\t\t\t\tleftBorderMap[tile] = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (!tileMap[tile - data.width]) {\r\n\t\t\t\t\ttopBorder.push(tile);\r\n\t\t\t\t\ttopBorderMap[tile] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresult.push({id: data.tiles[zone[0]], tileMap, leftBorder, leftBorderMap, topBorder, topBorderMap});\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates all connected zones of a map\r\n\t * @param data raw map data\r\n\t * @returns array of zone tiles for each zone\r\n\t * @private\r\n\t */\r\n\tprivate static calculateZones(data: RawMapData) {\r\n\t\tconst zoneTiles: number[][] = [];\r\n\t\tconst zoneCache = new Uint16Array(data.width); // one row of cache is enough\r\n\r\n\t\tfor (let i = 0; i < data.tiles.length; i++) {\r\n\t\t\tconst id = ZoneCalculator.findZone(i, data.tiles, data.width, zoneCache, zoneTiles);\r\n\t\t\tzoneCache[i % data.width] = id;\r\n\t\t\tzoneTiles[id].push(i);\r\n\t\t}\r\n\r\n\t\treturn zoneTiles.filter(zone => zone.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a tile into the zone map\r\n\t * @param tile index of the tile to check\r\n\t * @param tileTypes array of tile types\r\n\t * @param width width of the map\r\n\t * @param zoneCache cache of previous rows' zones\r\n\t * @param zoneTiles array of zone tiles\r\n\t * @returns the zone id of the tile\r\n\t * @private\r\n\t */\r\n\tprivate static findZone(tile: number, tileTypes: Uint16Array, width: number, zoneCache: Uint16Array, zoneTiles: number[][]) {\r\n\t\tconst type = tileTypes[tile];\r\n\t\tconst topType = tileTypes[tile - width];\r\n\t\tconst leftType = tileTypes[tile - 1];\r\n\t\tconst topZone = zoneCache[tile % width];\r\n\t\tconst leftZone = zoneCache[(tile + width - 1) % width];\r\n\r\n\t\tif (type === topType) {\r\n\t\t\tif (type === leftType) {\r\n\t\t\t\treturn ZoneCalculator.mergeZones(leftZone, topZone, zoneCache, zoneTiles);\r\n\t\t\t}\r\n\t\t\treturn topZone;\r\n\t\t} else if (type === leftType) {\r\n\t\t\treturn leftZone;\r\n\t\t}\r\n\r\n\t\tzoneTiles.push([]);\r\n\t\treturn zoneTiles.length - 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Merges adjacent zones of the same type\r\n\t * @param from zone to merge from\r\n\t * @param into zone to merge into\r\n\t * @param zoneCache cache of previous rows' zones\r\n\t * @param zoneTiles array of zone tiles\r\n\t * @returns the new zone id\r\n\t * @private\r\n\t */\r\n\tprivate static mergeZones(from: number, into: number, zoneCache: Uint16Array, zoneTiles: number[][]) {\r\n\t\tif (from === into) return into;\r\n\r\n\t\tif (zoneTiles[into].length < zoneTiles[from].length) {\r\n\t\t\t[into, from] = [from, into];\r\n\t\t}\r\n\t\tzoneTiles[into].push(...zoneTiles[from]);\r\n\t\tzoneTiles[from] = [];\r\n\t\tzoneCache.forEach((value, index) => {\r\n\t\t\tif (value === from) zoneCache[index] = into;\r\n\t\t});\r\n\t\treturn into;\r\n\t}\r\n}\r\n\r\nexport type TileZone = {\r\n\t/** Tile type of the zone */\r\n\tid: number;\r\n\ttileMap: boolean[];\r\n\tleftBorder: number[];\r\n\tleftBorderMap: boolean[];\r\n\ttopBorder: number[];\r\n\ttopBorderMap: boolean[];\r\n}","import {RawMapData} from \"../MapCodec\";\r\nimport {LazyWriter} from \"./util/LazyWriter\";\r\nimport {TileZone, ZoneCalculator} from \"./util/ZoneCalculator\";\r\n\r\nclass MapEncoder {\r\n\twidth: number = 0;\r\n\r\n\t/**\r\n\t * Writes compressed map data to a writer\r\n\t * @param writer writer to use\r\n\t * @param data map data to compress\r\n\t */\r\n\twriteCompressed(writer: LazyWriter, data: RawMapData): void {\r\n\t\twriter.writeBits(8, 0); //reserved for future use\r\n\t\tthis.width = data.width;\r\n\r\n\t\tconst zones = ZoneCalculator.buildZones(data);\r\n\r\n\t\tconst typeMap: number[] = [];\r\n\t\tlet nextTypeId = 0;\r\n\t\tfor (const zone of zones) {\r\n\t\t\tif (typeMap[zone.id] === undefined) {\r\n\t\t\t\ttypeMap[zone.id] = nextTypeId++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst typeLength = Math.ceil(Math.log2(Object.keys(typeMap).length));\r\n\r\n\t\tconst lines = this.calculateLines(writer, zones, typeLength);\r\n\r\n\t\twriter.writeBits(1, 0); //reserved for future use\r\n\r\n\t\tthis.writeTypeMap(writer, typeMap);\r\n\t\tthis.writeLines(writer, lines, typeLength, typeMap);\r\n\t}\r\n\r\n\t/**\r\n\t * Writes the type map, note that type ids are limited to 16 bits\r\n\t * @param writer writer to use\r\n\t * @param typeMap map of zone type ids to game type ids\r\n\t * @private\r\n\t */\r\n\tprivate writeTypeMap(writer: LazyWriter, typeMap: number[]) {\r\n\t\tconst typeMapLength = Object.keys(typeMap).length;\r\n\t\twriter.writeBits(16, typeMapLength);\r\n\t\tfor (let i = 0; i < typeMapLength; i++) {\r\n\t\t\twriter.writeBits(3, 0); //reserved for future use\r\n\t\t\twriter.writeBits(16, typeMap.indexOf(i));\r\n\t\t\t//TODO: rgb + extra data\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Writes compressed lines\r\n\t * @param writer writer to use\r\n\t * @param lines map lines to write\r\n\t * @param typeLength length of type ids\r\n\t * @param typeMap map of zone type ids to game type ids\r\n\t * @private\r\n\t */\r\n\tprivate writeLines(writer: LazyWriter, lines: LineData[], typeLength: number, typeMap: number[]) {\r\n\t\twriter.writeBits(32, lines.length);\r\n\r\n\t\tlet currentChunk = 0;\r\n\t\tfor (const line of lines) {\r\n\t\t\tcurrentChunk = this.checkChunk(writer, currentChunk, line.line[0]);\r\n\t\t\twriter.writeBits(1, 0); //reserved for future use\r\n\t\t\twriter.writeBits(8, line.line.length - 1);\r\n\t\t\twriter.writeBits(typeLength, typeMap[line.id]);\r\n\t\t\twriter.writeBits(10, (line.line[0] % this.width) % 32 + Math.floor(line.line[0] / this.width) % 32 * 32);\r\n\t\t\tfor (let i = 1; i < line.line.length; i++) {\r\n\t\t\t\tconst diff = line.line[i] - line.line[i - 1];\r\n\t\t\t\twriter.writeBits(2, diff === 1 ? 0 : diff === -1 ? 1 : diff === this.width ? 2 : 3);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the current chunk needs to be changed\r\n\t * @param writer writer to use\r\n\t * @param currentChunk current chunk\r\n\t * @param position position to check\r\n\t * @returns new chunk\r\n\t * @private\r\n\t */\r\n\tprivate checkChunk(writer: LazyWriter, currentChunk: number, position: number): number {\r\n\t\tconst chunkX = Math.floor((position % this.width) / 32);\r\n\t\tconst chunkY = Math.floor(Math.floor(position / this.width) / 32);\r\n\t\tconst chunk = chunkY * Math.ceil(this.width / 32) + chunkX;\r\n\t\twhile (chunk !== currentChunk) {\r\n\t\t\twriter.writeBits(1, 1);\r\n\t\t\tcurrentChunk++;\r\n\t\t}\r\n\t\twriter.writeBits(1, 0);\r\n\t\treturn currentChunk;\r\n\t}\r\n\r\n\t/**\r\n\t * Chunks lines into 32x32 blocks\r\n\t * @param lines lines to chunk\r\n\t * @private\r\n\t */\r\n\tprivate chunkLines(lines: LineData[]) {\r\n\t\tconst chunkWidth = Math.ceil(this.width / 32);\r\n\t\tconst chunkMap: number[] = [];\r\n\t\tfor (let i = 0; i < lines.length; i++) {\r\n\t\t\tconst line = lines[i];\r\n\t\t\tconst chunkX = Math.floor((line.line[0] % this.width) / 32);\r\n\t\t\tconst chunkY = Math.floor(Math.floor(line.line[0] / this.width) / 32);\r\n\t\t\tchunkMap[i] = chunkY * chunkWidth + chunkX;\r\n\t\t}\r\n\t\tlines.sort((a, b) => chunkMap[lines.indexOf(a)] - chunkMap[lines.indexOf(b)]);\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates lines along the border of each zone\r\n\t * @param writer writer to use\r\n\t * @param zones zones to calculate lines for\r\n\t * @param typeLength length of type ids\r\n\t * @returns resulting lines\r\n\t * @private\r\n\t */\r\n\tprivate calculateLines(writer: LazyWriter, zones: TileZone[], typeLength: number): LineData[] {\r\n\t\tconst linesL2R: LineData[] = [];\r\n\t\tconst linesT2B: LineData[] = [];\r\n\t\tfor (const zone of zones) {\r\n\t\t\tlinesL2R.push(...this.calculateNeededLines(zone.leftBorder, zone.leftBorderMap, zone.tileMap).map(line => ({id: zone.id, line})));\r\n\t\t\tlinesT2B.push(...this.calculateNeededLines(zone.topBorder, zone.topBorderMap, zone.tileMap).map(line => ({id: zone.id, line})));\r\n\t\t}\r\n\r\n\t\tthis.chunkLines(linesL2R);\r\n\t\tthis.chunkLines(linesT2B);\r\n\r\n\t\tconst costL2R = this.calculateCost(linesL2R, typeLength);\r\n\t\tconst costT2B = this.calculateCost(linesT2B, typeLength);\r\n\t\twriter.writeBoolean(costL2R > costT2B);\r\n\t\treturn costL2R > costT2B ? linesT2B : linesL2R;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the cost of a set of lines\r\n\t * @param lines lines to calculate cost for\r\n\t * @param typeLength length of type ids\r\n\t * @returns cost of the lines\r\n\t * @private\r\n\t */\r\n\tprivate calculateCost(lines: LineData[], typeLength: number): number {\r\n\t\tlet cost = 0;\r\n\r\n\t\tlet currentChunk = 0;\r\n\t\tfor (const line of lines) {\r\n\t\t\tconst chunk = Math.floor((line.line[0] % this.width) / 32) + Math.floor(Math.floor(line.line[0] / this.width) / 32) * Math.ceil(this.width / 32);\r\n\t\t\tcost += (line.line.length - 1) * 2 + 20 + typeLength + (chunk - currentChunk);\r\n\t\t\tcurrentChunk = chunk;\r\n\t\t}\r\n\t\treturn cost;\r\n\t}\r\n\r\n\t/**\r\n\t * Finds lines along the border of a zone allowing for lossless compression\r\n\t *\r\n\t * To allow reconstruction of the map, only certain points on the borders are needed.\r\n\t * Since the overhead of storing positions is pretty high, we can compress the border into lines.\r\n\t * This greedy algorithm tries to find the shortest possible lines that connect all border points.\r\n\t * For gaps greater than 8 tiles, multiple lines are used.\r\n\t *\r\n\t * @param points border points\r\n\t * @param pointMap map of border points\r\n\t * @param tileMap map of tiles\r\n\t * @returns resulting lines\r\n\t * @private\r\n\t */\r\n\tprivate calculateNeededLines(points: number[], pointMap: boolean[], tileMap: boolean[]): number[][] {\r\n\t\tconst segments: number[][] = [];\r\n\t\tconst segmentMap: number[] = [];\r\n\r\n\t\tconst connectionCount = new Uint8Array(points.length);\r\n\t\tconst connectionMap = this.calculateConnections(points, pointMap, tileMap);\r\n\r\n\t\tfor (let depth = 0; depth < connectionMap.length; depth++) {\r\n\t\t\tfor (const connection of connectionMap[depth]) {\r\n\t\t\t\tif (connectionCount[connection.from] >= 2 || connectionCount[connection.to] >= 2) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!MapEncoder.processConnection(!connectionCount[connection.from], !connectionCount[connection.to], connection, segments, points, segmentMap)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconnectionCount[connection.from]++;\r\n\t\t\t\tconnectionCount[connection.to]++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tMapEncoder.cropLines(segments);\r\n\t\tMapEncoder.addSingles(points, connectionCount, segments);\r\n\r\n\t\treturn segments.filter(segment => segment.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a connection between two border points\r\n\t * @param fromIsNew whether the starting point is new\r\n\t * @param toIsNew whether the ending point is new\r\n\t * @param connection connection to process\r\n\t * @param segments lines to add to\r\n\t * @param border border points\r\n\t * @param segmentMap map of border points to segments\r\n\t * @returns whether the segments were connected\r\n\t * @private\r\n\t */\r\n\tprivate static processConnection(fromIsNew: boolean, toIsNew: boolean, connection: RawLineData, segments: number[][], border: number[], segmentMap: number[]): boolean {\r\n\t\tconst valueFrom = border[connection.from];\r\n\t\tconst valueTo = border[connection.to];\r\n\t\tif (fromIsNew && toIsNew) {\r\n\t\t\tsegments.push([valueFrom, ...connection.path, valueTo]);\r\n\t\t\tsegmentMap[connection.from] = segmentMap[connection.to] = segments.length - 1;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (fromIsNew) {\r\n\t\t\tMapEncoder.concatSegment(segments[segmentMap[connection.to]], connection.path, valueTo, valueFrom);\r\n\t\t\tsegmentMap[connection.from] = segmentMap[connection.to];\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (toIsNew) {\r\n\t\t\tMapEncoder.concatSegment(segments[segmentMap[connection.from]], connection.path.reverse(), valueFrom, valueTo);\r\n\t\t\tsegmentMap[connection.to] = segmentMap[connection.from];\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (segmentMap[connection.from] !== segmentMap[connection.to]) {\r\n\t\t\tconst start = MapEncoder.connectSegments(segments[segmentMap[connection.from]], segments[segmentMap[connection.to]], valueFrom, valueTo, connection.path);\r\n\t\t\tsegments[segmentMap[connection.from]] = [];\r\n\t\t\tsegmentMap[border.indexOf(start)] = segmentMap[connection.to];\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Concatenates a path to a segment\r\n\t * @param segment segment to concatenate to\r\n\t * @param path path to concatenate\r\n\t * @param ending ending point of the segment\r\n\t * @param toAdd point to add to the segment\r\n\t * @private\r\n\t */\r\n\tprivate static concatSegment(segment: number[], path: number[], ending: number, toAdd: number) {\r\n\t\tif (segment[0] === ending) {\r\n\t\t\tsegment.unshift(toAdd, ...path);\r\n\t\t} else {\r\n\t\t\tsegment.push(...path.reverse(), toAdd);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Connects two segments into one\r\n\t * @param segmentA first segment\r\n\t * @param segmentB second segment\r\n\t * @param startA starting point of the first segment\r\n\t * @param startB starting point of the second segment\r\n\t * @param path path to connect the segments\r\n\t * @returns new starting value of the combined segment\r\n\t * @private\r\n\t */\r\n\tprivate static connectSegments(segmentA: number[], segmentB: number[], startA: number, startB: number, path: number[]): number {\r\n\t\tif (segmentB[0] === startB) {\r\n\t\t\tif (segmentA[0] === startA) {\r\n\t\t\t\tsegmentB.unshift(...segmentA.reverse(), ...path);\r\n\t\t\t} else {\r\n\t\t\t\tsegmentB.unshift(...segmentA, ...path);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (segmentA[0] === startA) {\r\n\t\t\t\tsegmentB.push(...path.reverse(), ...segmentA);\r\n\t\t\t} else {\r\n\t\t\t\tsegmentB.push(...path.reverse(), ...segmentA.reverse());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn segmentA[0] === startA ? segmentA[segmentA.length - 1] : segmentA[0];\r\n\t}\r\n\r\n\t/**\r\n\t * Adds lines for single points\r\n\t * @param border border points\r\n\t * @param connectionCount connection count for each point\r\n\t * @param lines lines to add to\r\n\t * @private\r\n\t */\r\n\tprivate static addSingles(border: number[], connectionCount: Uint8Array, lines: number[][]) {\r\n\t\tfor (let i = 0; i < border.length; i++) {\r\n\t\t\tif (connectionCount[i] === 0) {\r\n\t\t\t\tlines.push([border[i]]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Crops lines that are too long, splitting them into multiple lines\r\n\t * @param lines lines to crop\r\n\t * @private\r\n\t */\r\n\tprivate static cropLines(lines: number[][]) {\r\n\t\tfor (let i = 0; i < lines.length; i++) {\r\n\t\t\tconst line = lines[i];\r\n\t\t\tif (line && line.length > 256) {\r\n\t\t\t\tlines[i] = line.slice(0, 256);\r\n\t\t\t\tlines.push(line.slice(256));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates all potential connections between border points, at most 8 pixels apart\r\n\t * @param points border points\r\n\t * @param pointMap map of border points\r\n\t * @param tileMap map of tiles\r\n\t * @returns array of connections, indexed by path length\r\n\t * @private\r\n\t */\r\n\tprivate calculateConnections(points: number[], pointMap: boolean[], tileMap: boolean[]): RawLineData[][] {\r\n\t\tconst connectionMap: RawLineData[][] = new Array(8).fill(null).map(() => []);\r\n\t\tfor (let i = 0; i < points.length; i++) {\r\n\t\t\tconst paths = this.calculatePaths(points[i], pointMap, tileMap);\r\n\t\t\tfor (const [point, path] of paths) {\r\n\t\t\t\tconst index = points.indexOf(point);\r\n\t\t\t\tif (index >= i) continue; //only add each connection once\r\n\t\t\t\tconnectionMap[path.length].push({from: i, to: index, path});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn connectionMap;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates all paths from a point to all other points\r\n\t *\r\n\t * This is a simple breadth-first search, paths are limited to 8 tiles\r\n\t *\r\n\t * @param start starting point\r\n\t * @param pointMap map of border points\r\n\t * @param tileMap map of tiles\r\n\t * @returns map of reachable points and their paths\r\n\t * @private\r\n\t */\r\n\tprivate calculatePaths(start: number, pointMap: boolean[], tileMap: boolean[]): Map<number, number[]> {\r\n\t\tconst open: number[] = [start];\r\n\t\tconst paths: number[][] = [[]];\r\n\t\tconst visited: boolean[] = [];\r\n\t\tvisited[start] = true;\r\n\t\tconst result: Map<number, number[]> = new Map();\r\n\t\twhile (open.length > 0) {\r\n\t\t\tconst point = open.shift() as number;\r\n\t\t\tconst path = paths.shift() as number[];\r\n\t\t\tif (pointMap[point]) {\r\n\t\t\t\tresult.set(point, path.slice(0, -1));\r\n\t\t\t}\r\n\t\t\tif (path.length < 8) {\r\n\t\t\t\tfor (const nextPoint of [point - 1, point + 1, point - this.width, point + this.width]) {\r\n\t\t\t\t\tif (!visited[nextPoint] && tileMap[nextPoint]) {\r\n\t\t\t\t\t\topen.push(nextPoint);\r\n\t\t\t\t\t\tpaths.push([...path, nextPoint]);\r\n\t\t\t\t\t\tvisited[nextPoint] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\ntype RawLineData = {\r\n\tfrom: number;\r\n\tto: number;\r\n\tpath: number[];\r\n}\r\n\r\ntype LineData = {\r\n\tid: number;\r\n\tline: number[];\r\n}\r\n\r\nexport const mapEncoder = new MapEncoder();","export class StreamReader {\r\n\tprivate readonly buffer: Uint8Array;\r\n\tprivate offset: number = 0;\r\n\r\n\t/**\r\n\t * Creates a new reader for the given buffer\r\n\t * @param buffer buffer to read from\r\n\t */\r\n\tconstructor(buffer: Uint8Array) {\r\n\t\tthis.buffer = buffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Reads a number of bits from the buffer\r\n\t * @param length number of bits to read, must be less than or equal to 32\r\n\t * @returns number of value read\r\n\t * @throws Error if length is greater than 32 or there is not enough data to read\r\n\t */\r\n\treadBits(length: number): number {\r\n\t\tif (length > 32) throw new Error(\"Cannot read more than 32 bits at a time\");\r\n\t\tif (this.offset + length > this.buffer.length * 8) throw new Error(\"Not enough data to read\");\r\n\r\n\t\tlet value = 0;\r\n\t\tfor (let i = this.offset; i < this.offset + length; i++) {\r\n\t\t\tvalue |= ((this.buffer[i >>> 3] >>> (~i & 7)) & 1) << i - this.offset;\r\n\t\t}\r\n\t\tthis.offset += length;\r\n\t\treturn value >>> 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @param maxLength maximum length of the string\r\n\t * @returns string read from the buffer (utf-8)\r\n\t */\r\n\treadString(maxLength: number): string {\r\n\t\tconst max = Math.min(maxLength, this.readBits(16));\r\n\t\tlet value = \"\";\r\n\t\tfor (let i = 0; i < max; i++) {\r\n\t\t\tvalue += String.fromCharCode(this.readBits(8));\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns boolean read from the buffer\r\n\t */\r\n\treadBoolean(): boolean {\r\n\t\treturn this.readBits(1) === 1;\r\n\t}\r\n}","import {StreamReader} from \"./util/StreamReader\";\r\n\r\nclass MapDecoder {\r\n\t/**\r\n\t * Reads compressed map data from a reader\r\n\t * @param reader reader to use\r\n\t * @param width map width\r\n\t * @param height map height\r\n\t * @returns decompressed map data\r\n\t */\r\n\treadCompressed(reader: StreamReader, width: number, height: number): Uint16Array {\r\n\t\treader.readBits(8); //reserved for future use\r\n\t\tconst direction = reader.readBoolean(); //false if left-to-right, true if top-to-bottom\r\n\t\treader.readBits(1); //reserved for future use\r\n\r\n\t\tconst typeMap = this.readTypeMap(reader);\r\n\r\n\t\tconst typeLength = Math.ceil(Math.log2(typeMap.length));\r\n\r\n\t\tconst result = new Uint16Array(width * height);\r\n\t\tconst valueMap: boolean[] = [];\r\n\t\tthis.putLines(reader, result, valueMap, width, typeLength, typeMap);\r\n\t\tif (direction) {\r\n\t\t\tthis.fillLinesTopToBottom(result, valueMap, width);\r\n\t\t} else {\r\n\t\t\tthis.fillLinesLeftToRight(result, valueMap);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Reads the type map\r\n\t * @param reader reader to use\r\n\t * @returns type map\r\n\t * @private\r\n\t */\r\n\tprivate readTypeMap(reader: StreamReader): number[] {\r\n\t\tconst typeMapLength = reader.readBits(16);\r\n\t\tconst typeMap = [];\r\n\t\tfor (let i = 0; i < typeMapLength; i++) {\r\n\t\t\treader.readBits(3); //reserved for future use\r\n\t\t\ttypeMap.push(reader.readBits(16));\r\n\t\t}\r\n\t\treturn typeMap;\r\n\t}\r\n\r\n\t/**\r\n\t * Reads compressed lines and writes them to the result array\r\n\t * @param reader reader to use\r\n\t * @param result array to write to\r\n\t * @param valueMap map of values that have already been written\r\n\t * @param width map width\r\n\t * @param typeLength length of type ids\r\n\t * @param typeMap map of zone type ids to game type ids\r\n\t * @private\r\n\t */\r\n\tprivate putLines(reader: StreamReader, result: Uint16Array, valueMap: boolean[], width: number, typeLength: number, typeMap: number[]) {\r\n\t\tconst lineCount = reader.readBits(32);\r\n\r\n\t\tlet currentChunk = 0;\r\n\t\tfor (let i = 0; i < lineCount; i++) {\r\n\t\t\twhile (reader.readBoolean()) {\r\n\t\t\t\tcurrentChunk++;\r\n\t\t\t}\r\n\t\t\treader.readBits(1); //reserved for future use\r\n\t\t\tconst length = reader.readBits(8) + 1;\r\n\t\t\tconst type = typeMap[reader.readBits(typeLength)];\r\n\t\t\tlet position = reader.readBits(10);\r\n\t\t\tposition = (position % 32) + (currentChunk % Math.ceil(width / 32)) * 32 + Math.floor(position / 32) * width + Math.floor(currentChunk / Math.ceil(width / 32)) * 32 * width;\r\n\t\t\tresult[position] = type;\r\n\t\t\tvalueMap[position] = true;\r\n\t\t\tfor (let j = 1; j < length; j++) {\r\n\t\t\t\tconst diff = reader.readBits(2);\r\n\t\t\t\tposition += diff === 0 ? 1 : diff === 1 ? -1 : diff === 2 ? width : -width;\r\n\t\t\t\tresult[position] = type;\r\n\t\t\t\tvalueMap[position] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Fills in the gaps in the result array\r\n\t * @param result array to fill\r\n\t * @param valueMap map of values that have already been written\r\n\t * @private\r\n\t */\r\n\tprivate fillLinesLeftToRight(result: Uint16Array, valueMap: boolean[]) {\r\n\t\tlet current = 0;\r\n\t\tfor (let i = 0; i < result.length; i++) {\r\n\t\t\tif (valueMap[i]) {\r\n\t\t\t\tcurrent = result[i];\r\n\t\t\t}\r\n\t\t\tresult[i] = current;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Fills in the gaps in the result array\r\n\t * @param result array to fill\r\n\t * @param valueMap map of values that have already been written\r\n\t * @param width map width\r\n\t * @private\r\n\t */\r\n\tprivate fillLinesTopToBottom(result: Uint16Array, valueMap: boolean[], width: number) {\r\n\t\tlet current = 0;\r\n\t\tfor (let i = 0; i < result.length - 1; i = i >= result.length - width ? (i + 1) % width : i + width) {\r\n\t\t\tif (valueMap[i]) {\r\n\t\t\t\tcurrent = result[i];\r\n\t\t\t}\r\n\t\t\tresult[i] = current;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const mapDecoder = new MapDecoder();","import {TileType} from \"./tile/TileType\";\r\nimport {tileManager} from \"../Loader\";\r\n\r\nexport class GameMap {\r\n\tprivate readonly name: string;\r\n\treadonly width: number;\r\n\treadonly height: number;\r\n\tprivate readonly tiles: Uint16Array;\r\n\treadonly tileExpansionCosts: Uint8Array;\r\n\treadonly tileExpansionTimes: Uint8Array;\r\n\treadonly distanceMap: Int16Array;\r\n\r\n\tconstructor(name: string, width: number, height: number) {\r\n\t\tthis.name = name;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tthis.tiles = new Uint16Array(width * height);\r\n\t\tthis.tileExpansionCosts = new Uint8Array(width * height);\r\n\t\tthis.tileExpansionTimes = new Uint8Array(width * height);\r\n\t\tthis.distanceMap = new Int16Array(width * height);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the tile at the given index.\r\n\t *\r\n\t * If you want to check if a tile is solid, use {@link getDistance} instead.\r\n\t * @param index The index of the tile.\r\n\t * @returns The tile.\r\n\t */\r\n\tgetTile(index: number): TileType {\r\n\t\treturn tileManager.fromID(this.tiles[index]);\r\n\t}\r\n\r\n\t/**\r\n\t * Manipulates the tile at the given index.\r\n\t *\r\n\t * This method should only be called by map loaders / generators.\r\n\t * @param index The index of the tile.\r\n\t * @param tile The new tile.\r\n\t */\r\n\tsetTileId(index: number, tile: number): void {\r\n\t\tthis.tiles[index] = tile;\r\n\t\tthis.tileExpansionCosts[index] = tileManager.fromID(tile).expansionCost;\r\n\t\tthis.tileExpansionTimes[index] = tileManager.fromID(tile).expansionTime;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the distance to the nearest non-solid tile if the tile is solid (0 if bordering a non-solid tile).\r\n\t * If the tile is not solid, the distance is negative and the absolute value is the distance to the nearest solid tile (-1 if bordering a solid tile).\r\n\t *\r\n\t * Can also be used to determine whether a tile is solid or not (negative distance = not solid).\r\n\t * @param index The index of the tile.\r\n\t * @returns The distance of the tile.\r\n\t */\r\n\tgetDistance(index: number): number {\r\n\t\treturn this.distanceMap[index];\r\n\t}\r\n\r\n\t/**\r\n\t * Calculate the distance map.\r\n\t * @internal\r\n\t */\r\n\tcalculateDistanceMap(): void {\r\n\t\t//Calculate rows first\r\n\t\tfor (let y = 0; y < this.height; y++) {\r\n\t\t\tlet distance = this.getTile(y * this.width).isSolid ? 2 ** 15 - 1 : -1 * 2 ** 15;\r\n\t\t\tfor (let x = 0; x < this.width; x++) {\r\n\t\t\t\tthis.distanceMap[y * this.width + x] = distance = this.increaseDistance(y * this.width + x, distance);\r\n\t\t\t}\r\n\t\t\tdistance = this.getTile((y + 1) * this.width - 1).isSolid ? 2 ** 15 - 1 : -1 * 2 ** 15;\r\n\t\t\tfor (let x = this.width - 1; x >= 0; x--) {\r\n\t\t\t\tdistance = this.increaseDistance(y * this.width + x, distance);\r\n\t\t\t\tif (Math.abs(this.distanceMap[y * this.width + x]) > Math.abs(distance)) {\r\n\t\t\t\t\tthis.distanceMap[y * this.width + x] = distance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//Calculate columns\r\n\t\tfor (let x = 0; x < this.width; x++) {\r\n\t\t\tlet distance1 = this.getTile(x).isSolid ? 2 ** 15 - 1 : -1 * 2 ** 15;\r\n\t\t\tlet distance2 = this.getTile((this.height - 1) * this.width + x).isSolid ? 2 ** 15 - 1 : -1 * 2 ** 15;\r\n\t\t\tfor (let y = 0; y < this.height; y++) {\r\n\t\t\t\tdistance1 = this.increaseDistance(y * this.width + x, distance1);\r\n\t\t\t\tdistance2 = this.increaseDistance((this.height - 1 - y) * this.width + x, distance2);\r\n\t\t\t\tthis.distanceMap[y * this.width + x] = distance1 = Math.abs(this.distanceMap[y * this.width + x]) > Math.abs(distance1) ? distance1 : this.distanceMap[y * this.width + x];\r\n\t\t\t\tthis.distanceMap[(this.height - 1 - y) * this.width + x] = distance2 = Math.abs(this.distanceMap[(this.height - 1 - y) * this.width + x]) > Math.abs(distance2) ? distance2 : this.distanceMap[(this.height - 1 - y) * this.width + x];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Increase the distance to the nearest opposite tile by one.\r\n\t * @param index The index of the tile.\r\n\t * @param distance The current distance.\r\n\t * @returns The new distance.\r\n\t * @internal\r\n\t */\r\n\tprivate increaseDistance(index: number, distance: number): number {\r\n\t\treturn this.getTile(index).isSolid ? Math.max(distance + 1, 0) : Math.min(distance - 1, -1);\r\n\t}\r\n}","import {decodeMap} from \"./codec/MapCodec\";\r\nimport {GameMap} from \"./GameMap\";\r\nimport {InvalidArgumentException} from \"../util/exception/InvalidArgumentException\";\r\n\r\nconst mapRegistry: EncodedMapData[] = [];\r\n\r\ntype EncodedMapData = {\r\n\tname: string;\r\n\tdata: Uint8Array;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nfunction registerMap(name: string, base64Data: string) {\r\n\tmapRegistry.push({\r\n\t\tname: name,\r\n\t\tdata: Uint8Array.from(atob(base64Data), c => c.charCodeAt(0))\r\n\t});\r\n}\r\n\r\n/**\r\n * Retrieves a map from the registry by its ID.\r\n * @param id numeric ID of the map\r\n * @returns the map\r\n * @throws InvalidArgumentException if the map is not found\r\n */\r\nexport function mapFromId(id: number): GameMap {\r\n\tconst data = mapRegistry[id];\r\n\tif (!data) {\r\n\t\tthrow new InvalidArgumentException(`Map with id ${id} not found`);\r\n\t}\r\n\tconst decoded = decodeMap(data.data);\r\n\tconst map = new GameMap(data.name, decoded.width, decoded.height);\r\n\tfor (let i = 0; i < decoded.tiles.length; i++) {\r\n\t\tmap.setTileId(i, decoded.tiles[i]);\r\n\t}\r\n\tmap.calculateDistanceMap();\r\n\treturn map;\r\n}\r\n\r\n// The following lines are filled in by the build process\r\nregisterMap(\"Europe\", \"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GYGUCkMzGDqHdxwSQ7qv/zQHuZn8ZCd3z/PzAM+7vPPiQ9DruqY+80HNd3f+IBDzDCGB9d3wYQPwzP+IjLX33/mZgBpgAMMTAV33OyqwAfd3Xd3/B/V3Xd3d10AGjCsSt/ffdPfdXcAB9d3d3d0xCyCIIIf1n/+Ih+ADaQg/p1AB6EAM0wAwZDBbvXVX4Gfd/z++u//7/77ququ+ICTPGDZ/d+OFmgDDP6FATRhmfBCIfd3BRPszEAPM+iI37/d9ddRUJ76/vu7rvBAwfXdwIKB113f1AByAkGKtNI////4wPL77AAUp+SrP4M/qqc/8M/wAD8wMMM8/xI/h93d1V8GB8O667uAA7cyK8H3VVZmZwXUzMzoWp1d3dx94YEB46rrr84YW1666uGh3fVd9d3cfGDIn9wIBE674kEv92fzYxkYZh91d31SPFa1AM++P7umUQoWl/fdmaAYMO1VEcEe//jmtgrgAQBAEBBERFVVRRBBERREQQQRERUVVZVlWVjgmr93GIVXu67u67u4NQA54VVz++++HByvff2f/8/wNf/////////////////////////////////////////////////////////////////////////////////////4KIfQ++4+pVRRVVVhQgKf1DBB/78ALLgBk8AKP/wgaCHhA9//DQ8YYZmYZ9dmYZnmYZmFuP+7MM/8z6rzA+wM/DMD+uzDEjH5gGfZ54oepzMwwAn+MEzmmoACbHSrZ+f3BgYYf3dYGZ/35fFB/zDD8zMDz/P/P88zPM/u67u7788zPP/vuuxD7AwD+sIIg9xgYT6AD+sgCSYAAVAAqoAXWjx7wRRRVRUA/+84Dw//5kFlPvu/++40Xi6p7v+/vjsj33eH9359cf3Sz135/3dCBfbxoy/1fmIf33lxNdhURE9D8//w4uT1Pd33ddT3ABkwAJUlEv1EEfB/vu///uvVXu7uuPv7/swCTHmArvsxEl9TNmZ9f593ceMAyVegACZHyBngACtIqIiiAgIIILNCIIsjBQtD8QO/cEGA+o8FKNUt3ZlIHcMw/u//u7EQP/EhsXdwH3d0qOAd3d3ffBlhEgzz/7EhAHd3Xff4AEPAAKAAOIBAu/d5zg7Kf3AgGXu44iU0+7u7u+7u7u7icOj3Xdxh/13fdwGf3d33feSitD+/u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9OsRJq9deeZ4Z8GYAYASxADywAROCDq/nOBbR/mb02uuq777vuMP+qe8z+qP/gwzAM+wzMwAP9ADAMw8wAPpoXS/+/4cFpffd3nGTyHdn/4f9333/fxlRtJAM/77u4cgoBqqIq9d3fd9399XfffffXX+ZhhgAdIAIqEBVz///JgFB+f+Hmf/UNHyPz/PPPvsAP3woSp93d5//5EJbDMMzDMEEpBqCShneqREURFma6aqwzAAygACZIzyRngZmfX/ogf3eh+H+Qk3T6qPP788ED/iAwLjB5vvshPzGZmZgeBmAGBhx5Tp6u8/r7ahNA82ZmZzocJxmH/tcywAXo/MBhB5YCqMA88wwWU1XmGZHkurjMw/44MVdV4ZYI67u77uq777/PEMzD/sDP4MAzPggvZ3ABMqIQDM8DMzzMz/EQ/6zAP7MMD+75MJuz6vAP+rMys9J13cf5/9/9/3oIZ/93wwWywzADMxARu4AAfLDIBnhmeCggMzzM/6+/9UPP8+OlkT888/P/P8zMz+7/8tBI/f5/n5+fn5+fmZnwgD/5gBcoAIziB7/4AMyADMhARs+agzequ7v777rrrrr+8woWmGZ5mef//f33333/5///Z/3//8wJbhwAbcAHYCI1jmAasyoAbuACVIAWtiIJJmZZmalVquvzMRr///AH5+ZmqAIgAcAfPC/Wf55/95hnggf3WYYGH2eeGZfu7gDwYuL3X55hmZmDGgOqY/P664wA4kEEFvMQHXGAFlQA2qAGjSwy/3H8ZxKXYZ+ZmGeeeZ+fmZmZ//d1XVV1XVPXCoSrM1AFRBZqqaZlUEkGm913BBqMzCCbPUAEqv4ICP+uoIgb8fUz+Z/dV2iyy1dfnmZ4ZgGOCof6wDDCLBvf55mZgBoAIH4YeZ+eZngYBgFNVplmRUAPNRA//7+/zDFQzzJCSoL/4AcTl4Jfvj+oP78+64APzzP/s/vvAB6hwQG66gAupAB7+DBP///z/8/zyAl1nRj//v//zzz4WHMP/MzM/zM+u//zPPw8w0uR993//fnnnnhmgH5AXUwA2Z//8/wNf////////////////////////////////////////////////////////////////////////////////////+aBo++/6AAxJQejPMANEzMJj92YABmfmZmZgYfd30WCtDMz/8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qup7sUI5dXXUALxABZSIEcPgAFg3pKGYgGZ93UH93rdAAYYAZ9Vdd13eGZnmZnnmfn/5/+fnBATwP///NSeCqBmHx/d13Xd112HDsOuugD/+us8wH8ZgAeTHiRndddV1d300woAM6rquQEgf/kA+PEBXxgBq4AOfGBePqEAWuoANtABLUAJFQUUn11dVdXVU/3d5nkt1MMwP67PzMDAwAwAMDAzDMzxD+7M+//P/P8MOAAMP///AAywURsMwzPvu4AImABpbIBR2QEjucCV+/sIDi9QIMQAP8ACDA5lAz7uqfAwzPM88Az/Puvhs+KGfd1dV3XVU9d3BhmeeaFV///7/xgBW1WeCpO7gAQQQKt1f4AFIABxIEdJP7jP7zYtQoAHnwgGgGbGAuzwMDQAMAwAsMAEVp8Ha7u/u7j66nqQQh0YYcyENf9NPVSIGdaPuvj/8+/z7vvu/s/FCATTW1///4aDz6r8AP/uz+7vvu7sEPa5/8AGc5/KZNAwzzMwzMMzAw88D++Mz/zP+P7uzMA9AM80AEEP88/wAEeeEDwMz+6j6y6H5mZ+YZmGYYGZgefh92ef5/4B/YZ5mYYyeJ6Z6r+//u7vu7qbCs/uv//UA0AxgMX5+BBw/urj2oABjjBbM/MyNfcAOAiyJ4SL67umVECEZhBjnqEC/pzKUAiqrM1KzUisrVAiIjn6CgoA9//dX4QlYPzM888zMwwA88zMMDzMzMzDP8zDDDDAPMMzzFDDMz/DDMCBZ5QZY+4AMjgBhEANKgBY0AOtwQbbh4IAIXAAO4kS3zDMz7qAC8sADNZ/ga//////////////////////////////////////////////////////////////////////////////////////BA8CoHgB+6ICHuAhnIagIgiMCTGqy2pz1dhn391R93T1VPmfdUv9U911d3dT1S3f391dGh+P7u7gAg9///5BOy/jQA1WEQBBEWVllqWplZkEoI//cAGcpWGG8+/D/uzMzDDDAz/vDMaNDd31fX1VMmEQBmYBh4h+YwD9zDCAKBmEVfevMzMz4zMzMzMzDMzPunvv7DDSAfgCMQGumKGXeuuqBDxO8+7uMYHadflJHQ8MzM8QMP8DADACWExDBZhgYYf3d+YZ8UGguqhAjj7PLLHd3ddXf/4ZmYAfx99U/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\");\nregisterMap(\"World\", \"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5+f/5//x/3+f/n/+Z/n+ZhAZbzgAHP4uat/v/+///79aZVW7u//+rxA+0ZIOY/7/IBEGQByMwEafjgCJma/viARtlAy3s8CG/fYZgYZEGr6us/MOeGnj/p+MygY8Z/EC6BkAtD/gBV4AIhgAl4AHB//8/0mf3//313d3f113d1d1113ddd193d3fff5/d99/d9/fd9/ffff399/333d9/fd913Xd4f3f9/+ZnmHhmf0t/d15////8YNyn/DA2Xu+MHRj/igCN+f/5ge7/EA/xyAg9hBNbpiYhwMMMzzzzwz/+88zw8/zgNO1X+KHdPv/46PHegCIqgCKUlR/7u7uu6+7uu7oYEwdZkAXTCRw/XXd113d93d94gGO8oGk9+YALe8ZM4B91f4YH/3cB+GEBsDPEDzJiAZnv////lxmr+DDD41AwAyAfxmAGrqf8MPzMMM/7Pzw8/M/Mz/+8/zM//z/z////7z///jP9QwzPPPPz8PPMMzzPMzPPPz/P///7/7/v++rqqeuu6+7u76///5vW9DDAMM8/Pz8/z/z/Pz8/8/zz/P8/Pz/z/s/UM/7/+/F0nvdXXd/ff//999//5+Zn5nnn//3/39//+Z5/5gZgYBoeZmHniH/mf3ghmZ+ffh5///Li2/3f3Uq/x//gCj1RVBcD/777777/z8z/+/PzxVDPzDDDMzMwzQNADMwAzyger/5Ac//+Fdhe++vvuu7+67z7+6h7qXvv/vv67P7uu66+6uuu//6fz+/v7u//v//67u7qp+//7/+7/6/+/rGBwp+f///iB7QxANp3/////////gAUwAMmf////ADbYANb4gP4MgL8eAD/QAv7GhrR4fmZn/SQAmcqMtZ4Z5+ehiBRk///ADv4AG////wAvXmJldqpqtplaqZpmgAxeUBz+qABB4AGviRyEDAwMMMBOgtNNNM1TKyzMAAwYAbKAD1wAX+gBQn//////AW1gYZmZ55mYeefnnmGYZnmZ5nn5+eZ5mZh+f/+f/f/Hnn8BnmZhmZmBmAGzAoKZ3V3VV9YAIs//8gI4cGOKGYGIGAZhn+hTq7ur6XvP7vvvwP/+++77777+/7+++u+7u+++/7/v/v//v7/////77vvvvvv7+++++++777///+P/88/z/P/z8ACkT/kAYAHwABhhmGZmYZmZnmZmHmeZ55555meYZmfn/n5///9HnhmGBhgYZnn//+f3n/X/38f3ff+BmeZmBnmeZ5mGYUBAOq///zuc53V3d11/+IZn//+f39999/f//999/d9//ffd9393/mxDz8zzwzDM88SM5IC5/5/lg+bM//7Ng2XmGf/n5n8ZxPc67uz++7+7ruz+n7up66qe7rokBfeGByw0001TNABYrGmF5nn/H+f+eeZn8fnnn555mZhn/mef+fef5/5+f//3//3f//2fn//wAnjCSTvXf/ff/d13V140Y/6uuvv7+ggU79jAz88P////kJesM/+z8z++9QM4BV9dUKthAAYAYGBhmZ5nmeZ//dd3n/313XXfkARL///////wAjxKCqP9jRXLzAzMzMDAizhhmagGMFs+uhCE511d1XVT9dV33d38Z9/d93mLAcu67r2ung/MDZGYAY4KByP5kgPMAwOKChe+7P5Iar7+jMA1YcHLHmZmeeZnn/+GCGfmfn/+azD+6uMzPP++ur6u/DA8/8//7vv4+Pqe+7v6/7vABVX///8NIXn/3fn5/+Z/3n/Bmf41v8//Pw/vvz8/zPP/+/vP77PwPz8/zz88z8//PP/zz//v//v/PPP/7/PP/zz7PP/z+88/+/8//7zP/z//P7///xMJf+fZmfef9nh9+fh9WYAPTEA5PABdPKS2Qf/9dNL3Xf/3mGAsu4/w////////FzfwH8aIB//+H////B/0f30Shfuq+vu7+P77vv7ziAQbv4Qf58zAHz////+YGmsxAyr4wafz+Ihi/H/H+Blw8hE/uv77+MPgARyAGwAAqgAH0CAuxgBCgAPiAB1oAIcgBU0wOl//////w47OegjgAKtUCgBe+fCF2mv1Veqn//P///m1HIAMzMzA/88z/8wMMAD++MwzzzPMz+8/BDGxn3Hs7Lqu6rqqv4z/MPMM8zMMDMDMwzMMw8/P8DM/8zMoDrfn////wQs15h40VD/7rAB78ywhf1WH5lsJr/z+sPtE8/wA/PrsPrg/8Pqer6ZbvDMD7gzw1IhqvoeGfViIonMP/Dz+6sAD+KB/4ZmAmcMgOkYAWEKAIf3iBdUwAtqEC0+4ALukBGfAD94Ab/mBCvoABZgBVsAML5AdVxEtGGBhhnn3VPVUjBi1poSBoirLD3XjQKPrDDzParAA8IAWpADXIAc1////8AJ0TAn/0IAf+///4gaG8QM1mIBBvIANf////xAugYAa8AC+RsM8/r/umc+q7MweXdVH/9fX33x9cAfAAJkDmwMMD88wAeQAEoAAtQAFrJAZBwAxyEToWV6uqeruM+v/+8DD6qnvPwDBABwaIihIT8/zFDwWf4GAFDAA6cAFoSAHrwog8srP1U/RV+eADP6quuuuuu7u7o/7j/7u+/788wMMM/z/MPDDDMP8//uqruu7vzPMwwwAz4w8+P7M8wM+6jKClwBgAh4gAXf54ZuD+7uuCgN3d111ddf////////////hAr/r8ALzAAOb///////////8QJ38dj+1ZFAzAwMzDAAMwMwAMObGIcD0AMMAwPigr/+ZoO24MwMEAvBoCADNgAnWMBv+qYga4MqLPn1/GB/3ABgMgAcYYEf6q+zww3B9U/UIA4O////////////4UVlz0ABzz8YLVmHhBvszKIvfnn4GIZ5hmYYYBmB/5h9V4GZEAr8zMzMOYH8fxQ1iC/nlBkrPjA7gGAFaAAjwMCijwxALwZwLx7ugAGuQCDuMGAM/zQscgBn5aa0//araaZpqZqFaZBEAmhgQp7qDwNR///+MAcw8wQKOAYcMJS9U/VAhpPu6gYDr3fmBgGYGAhkwDPqz41A1ADADrIAe1gBSoABlSUlb3VVdVXAf11V13UYLB9VAAiMAD5wwgn1PVUcHy+qkAGlgA2vgBm0wG2hzoJKAAYB4Z+cELI998AG4SAPVgAyEAGoyAwVgBEEAKQnAMFqrABcIQFu44wdyM+FDAPVZ8EFye44DZcYZ0PJMwMDMwAMABAygS53YALalJg7qq6qrquqk//uKCGPXGQrEADA/MDhhW76664oClAHND7PVd3AALmUGseqADRJ4EJBAwwDKB2IBwonL1VXVffRAYRwQEiZgc8ACn5mGBgAOaLENuuqPz7v6qACgw4CG/v+zOIG+eKCD3VDB9HqqFF++urqo/6BCIvAAgAhkAEigACWcET8+oAMfgAxvmB174QO5+YCXvhATn////lBG/AYYSP+gARAAn4AQ/+YE+vgY5H1LdeAefUKGWf8z4AK2gBp00ERoB4GAArwgd1xggJ7qMyYOS1TXTTVVMw4X4B/Vh959h5hYg0PrqquwMD7j/uvwMADgJcjo+A/qn/wDzyQBQGYHMCA352URz+PM/u6pXq7rD66gADxQYKftXj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\");\r\n// End of map register block","import {territoryManager} from \"../TerritoryManager\";\r\nimport {HSLColor} from \"../../util/HSLColor\";\r\n\r\n/**\r\n * All game mode-specific logic should be implemented in a subclass of this class.\r\n * If needed, add more methods to this class to implement the desired game mode.\r\n */\r\nexport abstract class GameMode {\r\n\t/**\r\n\t * Returns whether a player can attack another player.\r\n\t * @param player The player that wants to attack.\r\n\t * @param target The player that is attacked.\r\n\t * @returns true if the player can attack the target, false otherwise.\r\n\t */\r\n\tcanAttack(player: number, target: number): boolean {\r\n\t\treturn player !== target && target !== territoryManager.OWNER_NONE - 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes the player color for this game mode.\r\n\t * Note that the color will later be passed through the theme for further processing.\r\n\t * @param _player The player id.\r\n\t * @param color The player color.\r\n\t * @returns The processed player color.\r\n\t */\r\n\tprocessPlayerColor(_player: number, color: HSLColor): HSLColor {\r\n\t\treturn color;\r\n\t}\r\n}","import {GameMode} from \"./GameMode\";\r\n\r\nexport class FFAGameMode extends GameMode {}","import { startGame } from \"../../game/Game\";\r\nimport { mapFromId } from \"../../map/MapRegistry\";\r\nimport { ModuleAdapter, closeAllModules, closeModule } from \"../ModuleLoader\";\r\nimport { openModule } from \"../ModuleLoader\";\r\nimport { FFAGameMode } from \"../../game/mode/FFAGameMode\";\r\nimport { getSetting, updateSetting } from \"../../util/UserSettingManager\";\r\n\r\nconst txtPlayerName: HTMLInputElement = (window.document.getElementById(\"txtPlayerName\") as HTMLInputElement);\r\nconst lblPlayerNameValidation: HTMLElement = (window.document.getElementById(\"lblPlayerNameValidation\") as HTMLElement);\r\nconst btnStart: HTMLButtonElement = (window.document.getElementById(\"btnStart\") as HTMLButtonElement)\r\n\r\nconst playerNameValidationExp: RegExp = /^[a-zA-Z0-9\\u00A0-\\u00FF\\u0100-\\u024F\\u1E00-\\u1EFF\\-_. ({)}<>]{3,32}$/;\r\n\r\nexport default {\r\n\t\r\n\tonOpen: () => {\r\n\t\tconst savedPlayerName = getSetting(\"playerName\");\r\n\t\tif (savedPlayerName)\r\n\t\t\ttxtPlayerName.value = savedPlayerName;\r\n\t}\r\n} as ModuleAdapter;\r\n\r\n(window as any).commandStartGame = function () {\r\n\tcloseAllModules();\r\n\topenModule(\"GameHud\");\r\n\tstartGame(mapFromId(Math.floor(Math.random() * 2)), new FFAGameMode());\r\n};\r\n\r\n(window as any).commandShowCommunity = function () {\r\n\topenModule(\"CommunityPanel\");\r\n};\r\n\r\n(window as any).commandShowImprint = function () {\r\n\topenModule(\"ImprintPanel\");\r\n};\r\n\r\n(window as any).commandShowPrivacy = function () {\r\n\topenModule(\"PrivacyPanel\");\r\n};\r\n\r\n(window as any).commandUpdateName = function () {\r\n\r\n\ttxtPlayerName.classList.remove(\"wf-form-control-error\");\r\n\tlblPlayerNameValidation.style.display = \"none\";\r\n\tlblPlayerNameValidation.innerHTML = \"\";\r\n\tbtnStart.disabled = false;\r\n\r\n\tif (playerNameValidationExp.test(txtPlayerName.value)) {\r\n\t\tupdateSetting(\"playerName\", txtPlayerName.value);\r\n\t} else {\r\n\t\ttxtPlayerName.classList.add(\"wf-form-control-error\");\r\n\t\tlblPlayerNameValidation.innerHTML = \"Name contains invalid characters.\";\r\n\t\tlblPlayerNameValidation.style.display = \"block\";\r\n\t\tbtnStart.disabled = true;\r\n\t}\r\n\t\r\n\tif (txtPlayerName.value.length < 3) {\r\n\t\ttxtPlayerName.classList.add(\"wf-form-control-error\");\r\n\t\tlblPlayerNameValidation.innerHTML = \"Name is too short (must be at least 3 characters).\";\r\n\t\tlblPlayerNameValidation.style.display = \"block\";\r\n\t\tbtnStart.disabled = true;\r\n\t}\r\n\r\n\tif (txtPlayerName.value.length > 32) {\r\n\t\ttxtPlayerName.classList.add(\"wf-form-control-error\");\r\n\t\tlblPlayerNameValidation.innerHTML = \"Name is too long (32 characters maximum).\";\r\n\t\tlblPlayerNameValidation.style.display = \"block\";\r\n\t\tbtnStart.disabled = true;\r\n\t}\r\n\r\n\r\n};\r\n\r\n","import {mapEncoder} from \"./src/MapEncoder\";\r\nimport {LazyWriter} from \"./src/util/LazyWriter\";\r\nimport {StreamReader} from \"./src/util/StreamReader\";\r\nimport {mapDecoder} from \"./src/MapDecoder\";\r\n\r\n// Only bump this for breaking changes, decompression should always be backwards compatible\r\nconst CURRENT_VERSION = 0;\r\n\r\n/**\r\n * Compresses map data\r\n * @param data map data to compress\r\n * @returns binary data\r\n */\r\nexport function encodeMap(data: RawMapData): Uint8Array {\r\n\tconst writer = new LazyWriter();\r\n\r\n\twriter.writeBits(4, CURRENT_VERSION);\r\n\twriter.writeBits(16, data.width);\r\n\twriter.writeBits(16, data.height);\r\n\tmapEncoder.writeCompressed(writer, data);\r\n\r\n\twriter.writeBits(8, 0); // reserved for future use\r\n\r\n\treturn writer.compress();\r\n}\r\n\r\n/**\r\n * Decompresses map data\r\n * @param data binary data\r\n * @returns raw map data\r\n */\r\nexport function decodeMap(data: Uint8Array): RawMapData {\r\n\tconst reader = new StreamReader(data);\r\n\r\n\tconst version = reader.readBits(4);\r\n\tif (version !== CURRENT_VERSION) {\r\n\t\tthrow new Error(`Unsupported map version: ${version}`);\r\n\t}\r\n\r\n\tconst width = reader.readBits(16);\r\n\tconst height = reader.readBits(16);\r\n\tconst tiles = mapDecoder.readCompressed(reader, width, height);\r\n\r\n\treader.readBits(8); // reserved for future use\r\n\r\n\treturn {width, height, tiles};\r\n}\r\n\r\nexport interface RawMapData {\r\n\twidth: number;\r\n\theight: number;\r\n\t/** 1D array of tile types */\r\n\ttiles: Uint16Array;\r\n}","import {closeModule} from \"../ModuleLoader\";\r\n\r\n(window as any).commandClosePrivacyPanel = function () {\r\n\tcloseModule(\"PrivacyPanel\");\r\n};","import { getSetting, updateSetting } from \"../../util/UserSettingManager\";\r\nimport {closeModule, ModuleAdapter} from \"../ModuleLoader\";\r\n\r\nconst switchGameClock = (window).document.getElementById(\"switchGameClock\") as HTMLInputElement;\r\n\r\nexport default {\r\n\tonOpen: () => {\r\n\t\t\tswitchGameClock.checked = getSetting(\"gameHud-clock\");\r\n\t}\r\n} as ModuleAdapter;\r\n\r\n(window as any).commandToggleClockSetting = function (element: HTMLInputElement) {\r\n\tupdateSetting(\"gameHud-clock\", element.checked);\r\n};\r\n\r\n(window as any).commandCloseSettingsPanel = function () {\r\n\tcloseModule(\"SettingsPanel\");\r\n};\r\n\r\n","import {HSLColor} from \"./HSLColor\";\r\n\r\n/**\r\n * Color in the RGBA format.\r\n */\r\nexport class RGBColor {\r\n\treadonly r: number;\r\n\treadonly g: number;\r\n\treadonly b: number;\r\n\treadonly a: number;\r\n\r\n\tconstructor(r: number, g: number, b: number, a: number = 1) {\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\t\tthis.a = a;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns A string representation of the color in the HSLA format.\r\n\t */\r\n\ttoString(): string {\r\n\t\treturn `(${this.r}, ${this.g}, ${this.b}, ${this.a})`;\r\n\t}\r\n\r\n\t/**\r\n\t * Write the color as a rgba value to a buffer.\r\n\t * @param buffer The buffer to write to.\r\n\t * @param offset The offset to write to.\r\n\t */\r\n\twriteToBuffer(buffer: Uint8Array | Uint8ClampedArray, offset: number): void {\r\n\t\tbuffer[offset] = this.r;\r\n\t\tbuffer[offset + 1] = this.g;\r\n\t\tbuffer[offset + 2] = this.b;\r\n\t\tbuffer[offset + 3] = this.a * 255 | 0\r\n\t}\r\n\r\n\t/**\r\n\t * Blend the color with a buffer.\r\n\t * The alpha channel is used for blending and not modified.\r\n\t * @param buffer The buffer to blend with.\r\n\t * @param offset The offset to blend with.\r\n\t * @param strength The strength of the blend, 0 for no change, 1 for full change.\r\n\t */\r\n\tblendWithBuffer(buffer: Uint8Array | Uint8ClampedArray, offset: number, strength: number = 1): void {\r\n\t\tbuffer[offset] = strength * this.a * this.r + (1 - strength * this.a) * buffer[offset];\r\n\t\tbuffer[offset + 1] = strength * this.a * this.g + (1 - strength * this.a) * buffer[offset + 1];\r\n\t\tbuffer[offset + 2] = strength * this.a * this.b + (1 - strength * this.a) * buffer[offset + 2];\r\n\t}\r\n\r\n\t/**\r\n\t * @param r The red value to set.\r\n\t * @returns A new color with the red value set.\r\n\t */\r\n\twithRed(r: number): RGBColor {\r\n\t\treturn new RGBColor(Math.min(Math.max(r, 0, 255)), this.g, this.b, this.a);\r\n\t}\r\n\r\n\t/**\r\n\t * @param g The green value to set.\r\n\t * @returns A new color with the green value set.\r\n\t */\r\n\twithGreen(g: number): RGBColor {\r\n\t\treturn new RGBColor(this.r, Math.min(Math.max(g, 0, 255)), this.b, this.a);\r\n\t}\r\n\r\n\t/**\r\n\t * @param b The blue value to set.\r\n\t * @returns A new color with the blue value set.\r\n\t */\r\n\twithBlue(b: number): RGBColor {\r\n\t\treturn new RGBColor(this.r, this.g, Math.min(Math.max(b, 0, 255), this.b, this.a));\r\n\t}\r\n\r\n\t/**\r\n\t * @param a The alpha value to set.\r\n\t * @returns A new color with the alpha value set.\r\n\t */\r\n\twithAlpha(a: number): HSLColor {\r\n\t\treturn new HSLColor(this.r, this.g, this.b, Math.min(Math.max(a, 0), 1));\r\n\t}\r\n}","import {RGBColor} from \"./RGBColor\";\r\n\r\n/**\r\n * Color in the HSLA format.\r\n */\r\nexport class HSLColor {\r\n\treadonly h: number;\r\n\treadonly s: number;\r\n\treadonly l: number;\r\n\treadonly a: number;\r\n\r\n\tconstructor(h: number, s: number, l: number, a: number = 1) {\r\n\t\tthis.h = h;\r\n\t\tthis.s = s;\r\n\t\tthis.l = l;\r\n\t\tthis.a = a;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns A string representation of the color in the HSLA format.\r\n\t */\r\n\ttoString(): string {\r\n\t\treturn `hsla(${this.h}, ${this.s * 100}%, ${this.l * 100}%, ${this.a})`;\r\n\t}\r\n\r\n\t/**\r\n\t * Convert the color to an RGB color.\r\n\t * @returns The color in the RGB format.\r\n\t */\r\n\ttoRGB(): RGBColor {\r\n\t\treturn new RGBColor(this.toRGBComponent(0), this.toRGBComponent(8), this.toRGBComponent(4), this.a);\r\n\t}\r\n\r\n\t/**\r\n\t * @param h The hue value to set.\r\n\t * @returns A new color with the hue value set.\r\n\t */\r\n\twithHue(h: number): HSLColor {\r\n\t\treturn new HSLColor((h % 360 + 360) % 360, this.s, this.l, this.a);\r\n\t}\r\n\r\n\t/**\r\n\t * @param s The saturation value to set.\r\n\t * @returns A new color with the saturation value set.\r\n\t */\r\n\twithSaturation(s: number): HSLColor {\r\n\t\treturn new HSLColor(this.h, Math.min(Math.max(s, 0), 1), this.l, this.a);\r\n\t}\r\n\r\n\t/**\r\n\t * @param l The lightness value to set.\r\n\t * @returns A new color with the lightness value set.\r\n\t */\r\n\twithLightness(l: number): HSLColor {\r\n\t\treturn new HSLColor(this.h, this.s, Math.min(Math.max(l, 0), 1), this.a);\r\n\t}\r\n\r\n\t/**\r\n\t * @param a The alpha value to set.\r\n\t * @returns A new color with the alpha value set.\r\n\t */\r\n\twithAlpha(a: number): HSLColor {\r\n\t\treturn new HSLColor(this.h, this.s, this.l, Math.min(Math.max(a, 0), 1));\r\n\t}\r\n\r\n\t/**\r\n\t * Create a color from an RGB value.\r\n\t * @param r The red value.\r\n\t * @param g The green value.\r\n\t * @param b The blue value.\r\n\t */\r\n\tstatic fromRGB(r: number, g: number, b: number): HSLColor {\r\n\t\tr /= 255;\r\n\t\tg /= 255;\r\n\t\tb /= 255;\r\n\t\tconst max = Math.max(r, g, b);\r\n\t\tconst min = Math.min(r, g, b);\r\n\t\tconst diff = max - min;\r\n\t\tconst divisor = 1 - Math.abs(min + max - 1);\r\n\t\tlet hue = 0;\r\n\t\tif (diff !== 0) {\r\n\t\t\tswitch (max) {\r\n\t\t\t\tcase r:\r\n\t\t\t\t\thue = (g - b) / diff % 6;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase g:\r\n\t\t\t\t\thue = (b - r) / diff + 2;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase b:\r\n\t\t\t\t\thue = (r - g) / diff + 4;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\thue = 60 * (hue < 0 ? hue + 6 : hue);\r\n\t\t}\r\n\t\treturn new HSLColor(hue, divisor === 0 ? 0 : diff / divisor, (max + min) / 2);\r\n\t}\r\n\r\n\t/**\r\n\t * Approximates the RGB value of the color.\r\n\t * @param component The component to approximate, 0 for red, 8 for green, 4 for blue.\r\n\t * @private\r\n\t */\r\n\tprivate toRGBComponent(component: number) {\r\n\t\tconst k = (component + this.h / 30) % 12;\r\n\t\tconst a = this.s * Math.min(this.l, 1 - this.l);\r\n\t\treturn Math.round(255 * (this.l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1))));\r\n\t}\r\n\r\n\t/**\r\n\t * Create a color from an RGBA value.\r\n\t * @param r The red value.\r\n\t * @param g The green value.\r\n\t * @param b The blue value.\r\n\t * @param a The alpha value.\r\n\t */\r\n\tstatic fromRGBA(r: number, g: number, b: number, a: number): HSLColor {\r\n\t\treturn HSLColor.fromRGB(r, g, b).withAlpha(a);\r\n\t}\r\n\r\n\t/**\r\n\t * Create a color from an RGB color.\r\n\t * @param color The color to convert.\r\n\t */\r\n\tstatic fromRGBColor(color: RGBColor): HSLColor {\r\n\t\treturn HSLColor.fromRGB(color.r, color.g, color.b).withAlpha(color.a);\r\n\t}\r\n}","export function formatTroops(troops: number): string {\r\n\tlet result = \"\";\r\n\twhile (troops > 1000) {\r\n\t\tresult = (troops % 1000).toString().padStart(3, \"0\") + result;\r\n\t\ttroops = Math.floor(troops / 1000);\r\n\t\tif (troops > 0) result = \".\" + result;\r\n\t}\r\n\treturn troops.toString() + result;\r\n}\r\n\r\nexport function formatTime(time: number): string {\r\n    const pad = (n: number, z: number = 2) => ('00' + n).slice(-z);\r\n    \r\n    const minutes = Math.floor(time / 60000);\r\n    time %= 60000;\r\n    const seconds = Math.floor(time / 1000);\r\n    const milliseconds = (time % 1000) / 10;\r\n    \r\n    return `${pad(minutes)}:${pad(seconds)}:${pad(milliseconds, 2)}`;\r\n}","import {UnsupportedDataException} from \"./exception/UnsupportedDataException\";\r\n\r\n/**\r\n * Important Note: For types to work correctly, all register calls must be chained together.\r\n * @internal\r\n */\r\nexport class SettingRegistry<T extends Record<string, Setting<unknown>>> {\r\n\tprivate registry: T = {} as T;\r\n\tprivate updaters: Record<string, Record<number, (value: string) => string>> = {};\r\n\r\n\t/**\r\n\t * Create a new setting registry\r\n\t * @internal\r\n\t */\r\n\tstatic init() {\r\n\t\treturn new SettingRegistry<{}>();\r\n\t}\r\n\r\n\t/**\r\n\t * Register a setting\r\n\t * @param key stringy id of the setting\r\n\t * @param setting the setting object\r\n\t * @see Setting\r\n\t */\r\n\tregister<K extends string, S>(key: K & Exclude<K, keyof T>, setting: Setting<S>): SettingRegistry<T & Record<K, Setting<S>>> {\r\n\t\t(this.registry as unknown as Record<K, Setting<S>>)[key] = setting;\r\n\t\treturn this as unknown as SettingRegistry<T & Record<K, Setting<S>>>;\r\n\t}\r\n\r\n\t/**\r\n\t * Register a simple updatable setting\r\n\t * Requires the setting type to implement a toString method\r\n\t * @param key stringy id of the setting\r\n\t * @param defaultValue the default value of the setting\r\n\t * @param decode the decode function of the setting\r\n\t * @param version the version of the setting\r\n\t */\r\n\tregisterUpdatable<K extends string, U extends {toString: (this: U) => string}>(key: K & Exclude<K, keyof T>, defaultValue: U, decode: (this: void, value: string) => U, version: number = 0) {\r\n\t\treturn this.register<K, U>(key, {\r\n\t\t\tencode: function (this: U) { return this.toString(); },\r\n\t\t\tdecode: this.decodeUpdatable.bind(this, key, defaultValue, decode) as Setting<U>[\"decode\"],\r\n\t\t\tdefaultValue,\r\n\t\t\tvalue: defaultValue,\r\n\t\t\tversion\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Decode an updatable setting or return the default value if decoding fails\r\n\t * @param key the key of the setting\r\n\t * @param defaultValue the default value of the setting\r\n\t * @param decode the decode function of the setting\r\n\t * @param value the value to decode\r\n\t * @param version the version of the setting\r\n\t */\r\n\tprivate decodeUpdatable<U>(key: string & keyof T, defaultValue: U, decode: (this: void, value: string) => U, value: string, version: number): U {\r\n\t\ttry {\r\n\t\t\treturn decode(this.applyUpdaters(key, value, version));\r\n\t\t} catch (e) {\r\n\t\t\tconsole.warn(`Failed to decode setting ${key}:`, e);\r\n\t\t\treturn defaultValue;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Apply all available updaters to a setting\r\n\t * @param key the key of the setting\r\n\t * @param value the value to update\r\n\t * @param oldVer the version of the value prior to the update\r\n\t * @throws UnsupportedDataException if no fitting updater is found\r\n\t */\r\n\tprivate applyUpdaters(key: string & keyof T, value: string, oldVer: number): string {\r\n\t\tconst setting = this.registry[key];\r\n\t\tif (!setting.version || oldVer >= setting.version) return value;\r\n\t\twhile (setting.version > oldVer) {\r\n\t\t\tconst updater = this.updaters[key][oldVer];\r\n\t\t\tif (updater) {\r\n\t\t\t\tvalue = updater(value);\r\n\t\t\t\toldVer++;\r\n\t\t\t} else {\r\n\t\t\t\t// We don't save the setting here, in case the updater is added later\r\n\t\t\t\tthrow new UnsupportedDataException(`No updater found for setting ${key} from version ${oldVer}`);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.saveSetting(key);\r\n\t\treturn value;\r\n\t}\r\n\r\n\tregisterString<K extends string>(key: K & Exclude<K, keyof T>, defaultValue: string, version: number = 0) {\r\n\t\treturn this.registerUpdatable<K, string>(key, defaultValue, String, version);\r\n\t}\r\n\r\n\tregisterNumber<K extends string>(key: K & Exclude<K, keyof T>, defaultValue: number, version: number = 0) {\r\n\t\treturn this.registerUpdatable<K, number>(key, defaultValue, parseFloat, version);\r\n\t}\r\n\r\n\tregisterInteger<K extends string>(key: K & Exclude<K, keyof T>, defaultValue: number, version: number = 0) {\r\n\t\treturn this.registerUpdatable<K, number>(key, defaultValue, parseInt, version);\r\n\t}\r\n\r\n\tregisterBoolean<K extends string>(key: K & Exclude<K, keyof T>, defaultValue: boolean, version: number = 0) {\r\n\t\treturn this.registerUpdatable<K, boolean>(key, defaultValue, value => value === \"true\", version);\r\n\t}\r\n\r\n\t/**\r\n\t * Register an updater for a setting\r\n\t * @param key the key of the setting\r\n\t * @param version the version of the setting\r\n\t * @param updater the updater function\r\n\t */\r\n\tregisterUpdater<K extends string>(key: K, version: number, updater: (value: string) => string) {\r\n\t\tif (!this.updaters[key]) {\r\n\t\t\tthis.updaters[key] = {};\r\n\t\t}\r\n\t\tthis.updaters[key][version] = updater;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Load all settings from local storage\r\n\t */\r\n\tload() {\r\n\t\tfor (const key in this.registry) {\r\n\t\t\tconst setting = this.registry[key];\r\n\t\t\tconst value = localStorage.getItem(key);\r\n\t\t\tif (value && value.match(/^.*:\\d+$/)) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst result = value.match(/^(.*):(\\d+)$/);\r\n\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\tsetting.value = setting.decode(result[1], parseInt(result[2]));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.warn(`Failed to load setting ${key}: Invalid format`);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tconsole.error(`Failed to load setting ${key}:`, e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Save a setting to local storage\r\n\t */\r\n\tsaveSetting<K extends string & keyof T>(key: K) {\r\n\t\tconst setting = this.registry[key];\r\n\t\tlocalStorage.setItem(key, `${setting.encode.call(setting.value)}:${setting.version}`);\r\n\t}\r\n\r\n\t/**\r\n\t * Get a setting\r\n\t * @param key the key of the setting\r\n\t * @returns the setting object\r\n\t * @see Setting\r\n\t */\r\n\tget<K extends keyof T>(key: K): T[K] {\r\n\t\treturn this.registry[key];\r\n\t}\r\n\r\n\t/**\r\n\t * Get all settings\r\n\t * @returns an array of all settings\r\n\t */\r\n\tgetAll() {\r\n\t\tconst result: Setting<unknown>[] = [];\r\n\t\tfor (const key in this.registry) {\r\n\t\t\tresult.push(this.registry[key]);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\n/**\r\n * Setting object\r\n * Requires encode and decode function to load and save the setting\r\n */\r\nexport type Setting<T> = {\r\n\tencode: (this: T) => string,\r\n\tdecode: (this: Setting<T>, value: string, version: number) => T,\r\n\tdefaultValue: T,\r\n\tvalue: T,\r\n\tversion?: number\r\n}","import {HSLColor} from \"../util/HSLColor\";\r\nimport {TileType} from \"../map/tile/TileType\";\r\n\r\n/**\r\n * All colors, fonts, and other theme-related properties should be passed through a theme object.\r\n * This allows for easy customization of the game's appearance.\r\n */\r\nexport type GameTheme = {\r\n\treadonly id: string;\r\n\ttoString(): string;\r\n\r\n\t/**\r\n\t * Get the color of a territory.\r\n\t * @param color base player color\r\n\t * @returns the color of the territory\r\n\t */\r\n\tgetTerritoryColor(color: HSLColor): HSLColor;\r\n\r\n\t/**\r\n\t * Get the border color of a territory.\r\n\t * @param color base player color\r\n\t * @returns the border color of the territory\r\n\t */\r\n\tgetBorderColor(color: HSLColor): HSLColor;\r\n\r\n\t/**\r\n\t * Get the color of a tile.\r\n\t * @param tile the type of the tile\r\n\t * @returns the color of the tile\r\n\t */\r\n\tgetTileColor(tile: TileType): HSLColor;\r\n\r\n\t/**\r\n\t * Get the color of the background.\r\n\t * @returns the color of the background\r\n\t */\r\n\tgetBackgroundColor(): HSLColor;\r\n\r\n\t/**\r\n\t * Get the font of the game.\r\n\t * @returns the font of the game\r\n\t */\r\n\tgetFont(): string;\r\n\r\n\t/**\r\n\t * Get the list of shaders to use.\r\n\t * @returns the list of shaders to use\r\n\t * @internal\r\n\t */\r\n\tgetShaderArgs(): {name: string, args: {[key: string]: unknown}}[];\r\n}\r\n\r\nconst registry: Record<string, GameTheme> = {};\r\n\r\n/**\r\n * Registers a theme.\r\n * @param id the name of the theme\r\n * @param theme the theme\r\n * @param tileOverrides overrides for tile colors\r\n */\r\nexport function registerTheme(id: string, theme: Omit<GameTheme, \"id\">, tileOverrides: Record<string, HSLColor>) {\r\n\tconst originalGetTileColor = theme.getTileColor;\r\n\ttheme.getTileColor = (tile: TileType) => {\r\n\t\tif (tile.internalName in tileOverrides) {\r\n\t\t\treturn tileOverrides[tile.internalName];\r\n\t\t}\r\n\t\treturn originalGetTileColor(tile);\r\n\t}\r\n\tregistry[id] = {\r\n\t\tid,\r\n\t\t...theme,\r\n\t\ttoString: function (this: GameTheme) {\r\n\t\t\treturn this.id\r\n\t\t},\r\n\t}\r\n}\r\n\r\n/**\r\n * Retrieves a theme from the registry by its name.\r\n * @param id the name of the theme\r\n * @returns the theme\r\n */\r\nexport function getTheme(id: string): GameTheme {\r\n\tconst theme = registry[id];\r\n\tif (!theme) {\r\n\t\tthrow new Error(`Theme ${id} not found`);\r\n\t}\r\n\treturn theme;\r\n}\r\n\r\n// The following lines are filled in by the build process\r\nregisterTheme(\"pastel\", {\n\t\t\t\tgetTerritoryColor(color: HSLColor): HSLColor {\n\t\t\t\t\treturn color.withSaturation(color.s * 0.5).withLightness(0.75);\n\t\t\t\t},\n\t\t\t\tgetBorderColor(color: HSLColor): HSLColor {\n\t\t\t\t\treturn color.withSaturation(color.s * 0.5).withLightness(0.65);\n\t\t\t\t},\n\t\t\t\tgetTileColor(tile: TileType): HSLColor {\n\t\t\t\t\tconst color = tile.baseColor;\n\t\t\t\t\treturn color.withLightness(0.8);\n\t\t\t\t},\n\t\t\t\tgetBackgroundColor(): HSLColor {\n\t\t\t\t\treturn HSLColor.fromRGB(123, 166, 194);\n\t\t\t\t},\n\t\t\t\tgetFont(): string {\n\t\t\t\t\treturn \"Overpass\";\n\t\t\t\t},\n\t\t\t\tgetShaderArgs(): {name: string, args: {[key: string]: any}}[] {\n\t\t\t\t\treturn [{name: \"territory-outline\", args: {\"color\": HSLColor.fromRGBA(152, 185, 223, 1), \"thickness\": 1}}, {name: \"territory-outline-smooth\", args: {\"color\": HSLColor.fromRGBA(255, 255, 255, 0.1), \"thickness\": 15}}, {name: \"territory-inline\", args: {\"color\": HSLColor.fromRGBA(201, 187, 139, 1), \"thickness\": 1}}];\n\t\t\t\t}\n\t\t\t}, {\"grass\": HSLColor.fromRGB(244, 243, 198), \"water\": HSLColor.fromRGB(160, 203, 231)});\r\n// End of theme register block","import {SettingRegistry} from \"./SettingRegistry\";\r\nimport {getTheme} from \"../renderer/GameTheme\";\r\n\r\n/**\r\n * Setting registry, all register calls need to be chained together\r\n */\r\nconst registry = SettingRegistry.init()\r\n\t.registerUpdatable(\"theme\", getTheme(\"pastel\"), (value: string) => getTheme(value))\r\n\t.registerString(\"playerName\", \"UnknownPlayer\")\r\n\t.registerBoolean(\"gameHud-clock\", true)\r\n\t.registerString(\"api-location\", \"https://warfront.io/api\") //This needs to enforce no trailing slash, no query parameters and a protocol\r\n\t.registerString(\"game-server\", \"warfront.io\")\r\n\r\nregistry.load();\r\n\r\nconst listeners: Record<string, ((value: any) => void)[]> = {};\r\n\r\n/**\r\n * Get a setting value\r\n * @param key identifier of the setting\r\n */\r\nexport function getSetting<K extends keyof typeof registry[\"registry\"]>(key: K): typeof registry[\"registry\"][K][\"value\"] {\r\n\treturn registry.get(key).value;\r\n}\r\n\r\n/**\r\n * Update and save a setting value\r\n * @param key identifier of the setting\r\n * @param value new value\r\n */\r\nexport function updateSetting<K extends keyof typeof registry[\"registry\"]>(key: K, value: typeof registry[\"registry\"][K][\"value\"]) {\r\n\tif (listeners[key]) {\r\n\t\tfor (const listener of listeners[key]) {\r\n\t\t\tlistener(value);\r\n\t\t}\r\n\t}\r\n\r\n\tregistry.get(key).value = value;\r\n\tregistry.saveSetting(key);\r\n}\r\n\r\n/**\r\n * Register a setting listener that will be called before the value is updated\r\n * @param key identifier of the setting\r\n * @param listener listener to register, argument is the new value of the setting\r\n */\r\nexport function registerSettingListener<K extends keyof typeof registry[\"registry\"]>(key: K, listener: (value: typeof registry[\"registry\"][K][\"value\"]) => void) {\r\n\tif (!listeners[key]) listeners[key] = [];\r\n\tlisteners[key].push(listener);\r\n}","export class InvalidArgumentException extends Error {\r\n\tconstructor(message: string) {\r\n\t\tsuper(message);\r\n\t}\r\n}","export class UnsupportedDataException extends Error {\r\n\tconstructor(message: string) {\r\n\t\tsuper(message);\r\n\t}\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(33);\n"],"names":["modules","Map","moduleAdapters","openModules","openModule","name","module","get","onOpen","style","display","push","closeModule","includes","filter","item","closeAllModules","forEach","registerModule","adapter","element","document","getElementById","set","documentElement","classList","add","id","theme","remove","window","addEventListener","TileType","expansionTime","expansionCost","TileTypeIds","WaterTile","WATER","internalName","baseColor","HSLColor","fromRGB","isSolid","render","_context","_x","_y","GrassTile","GRASS","userAccount","account","username","avatar_url","avatarURL","service","serviceId","user_id","apiToUserAccount","accountSwitchHandler","broadcast","EventHandlerRegistry","listener","endpointPOST","url","auth","params","APIResponse","post","replace","_","key","value","fillPathParams","constructor","options","listeners","errorListener","result","then","fetch","response","headers","json","data","this","handleResponse","status","catch","handleError","bind","text","error","code","on","callback","method","URLSearchParams","toString","getUserToken","refresh","token","addAuth","Promise","resolve","body","refreshToken","ActualUserToken","expires","Date","now","fetchUserToken","conf","Authorization","getRawToken","InvalidUserToken","userToken","refreshTokenCookie","cookie","lastSeenValue","fetchValue","matches","match","RegExp","pop","lifetime","forceSet","toUTCString","promise","func","args","tryFetchUserToken","undefined","isPending","buildPromiseBundle","retries","refresh_token","user","access_token","expires_in","console","warn","err","log","paths","_path","state","InvalidArgumentException","sessionStorage","getItem","removeItem","history","replaceState","tileManager","tileTypes","registerTileType","tileType","UnsupportedDataException","overrideTileType","existingTileType","fromID","path","location","pathname","search","slice","e","handlePath","callImmediately","handleListener","register","unregister","l","gameTicker","TICK_INTERVAL","registry","start","tickCount","ticker","setInterval","tick","stop","clearInterval","getTickCount","getElapsedTime","gameClock","lblGameTime","innerHTML","f","show","commandShowSettings","commandExitGame","reload","commandCloseImprintPanel","PrioritizedEventHandlerRegistry","currentListener","prioritize","unshift","reset","choose","x","y","find","test","call","handler","interactionManager","click","drag","scroll","multitouch","hover","dragTimeout","pressX","pressY","touchPoints","onPointerDown","onPointerUp","onHover","onScroll","passive","event","pointerId","size","setTimeout","onDragStart","delete","point","values","next","clearTimeout","onClick","onDragEnd","Math","abs","checkMobileGesture","onDragMove","delta","deltaY","ctrlKey","preventDefault","oldPoint1","oldPoint2","Array","from","newPoint1","newPoint2","oldDistance","hypot","zoomFactor","oldCenterX","oldCenterY","newCenterX","newCenterY","onMultiTouch","mapTransformHandler","scale","mapNavigationHandler","zoom","move","enable","minXZoom","innerWidth","gameMap","width","minYZoom","innerHeight","height","min","disable","processZoom","newZoom","mapX","getMapX","mapY","getMapY","max","oldX","oldY","newX","newY","factor","dx","dy","isOnMap","getIndex","floor","onNeighbors","tile","closure","bordersTile","player","territoryManager","isOwner","PriorityQueue","comparator","heap","isEmpty","length","peek","siftUp","siftDown","update","predicate","index","findIndex","node","parentIndex","maxParent","leftIndex","rightIndex","leftValue","rightValue","random","seed","t","imul","nextInt","PlayerNameRenderingData","troopLength","borderSet","updateTick","nameX","nameY","troopSize","queue","a","b","renderName","playerNameRenderingManager","partialAtlasContext","fillStyle","font","nameLength","measureText","getFont","fillText","atlasRowLength","handleAdd","pos","setPosAt","handleRemove","nameDepth","newMax","newPos","tileOwners","renderPlayer","context","updatePartial","textBaseline","getTroops","drawImage","partialElementAtlas","clearRect","playerData","createElement","currentPlayerMax","currentPlayerPos","currentTargetMax","currentTargetPos","maxPlayers","Uint16Array","sqrt","ceil","getContext","textRendering","textAlign","registerPlayer","borderTiles","finishRegistration","players","isConsidered","addTile","recalculateFrom","removeTile","changed","offset","rowMax","Infinity","columnMax","i","applyTransaction","target","currentOrigin","isColumn","maxPos","currentMax","otherMax","current","CachedLayer","canvas","resizeCanvas","territoryRenderer","invalidateCaches","onMapMove","onMapScale","territoryRenderingManager","territoryQueue","playerBorderQueue","targetBorderQueue","setTerritory","setPlayerBorder","setTargetBorder","clear","paintTiles","getBorderColor","getTerritoryColor","tiles","color","fillRect","forceRepaint","isPlaying","colorCache","owner","getOwner","OWNER_NONE","playerManager","getPlayer","isTerritory","AttackExecutor","troops","tileQueue","basePriority","orderTiles","modifyTroops","amount","oppose","troopCount","attackCost","calculateAttackCost","defenseCost","conquered","conquer","tileExpansionCosts","removeTroops","calculateSpeedFactor","handlePlayerTileAdd","neighbor","tileExpansionTimes","handleTargetTileAdd","amountCache","attackActionHandler","priority","getTerritorySize","attacks","playerIndex","unclaimedIndex","playerAttackList","targetAttackList","unclaimedAttackList","init","fill","map","Uint8Array","preprocessAttack","percentage","gameMode","canAttack","attackPlayer","attackUnclaimed","hasBorderWith","parent","addUnclaimed","getAttack","opposite","removeAttack","addAttack","attack","splice","indexOf","addTroops","handleTerritoryAdd","Player","Set","territorySize","alive","processPlayerColor","isBorder","has","income","territoryMultiplier","isAlive","BotPlayer","super","targets","border","SpawnData","spawnManager","radius","spawnPoints","buildSpawns","spawnData","backupPoints","isSelecting","minDistance","cellSize","rows","cols","grid","active","points","initialX","initialY","initial","px","py","found","tries","angle","PI","distance","cos","sin","cellX","cellY","valid","j","other","ox","oy","getTile","randomSpawnPoint","getSpawnPixels","pixel","selectSpawnPoint","pixels","blockedPoints","isLocalGame","hasOwner","incomeLoopLength","humans","clientId","bots","clientPlayer","isBot","bot","gameTick","areaCalculator","AREA_SIZE","isLoaded","preprocessMap","graph","nodeIndex","areaIndex","currentNodeId","canonicalAreaId","createAreas","area","checkConnections","topLeft","nodes","topRight","bottomLeft","bottomRight","edges","cost","cache","buildAreaGraph","areas","Area","otherX","otherY","allowed","entranceStart","addEdge","area1","area2","x1","y1","x2","y2","node1","getOrCreateNode","node2","Node","isAreaEmpty","calculateDistancesRaw","others","minX","minY","isSetting","stack","stackPointer","queuePointer","parentMap","nx","ny","getDistance","lastX","lastY","level","previousOwner","Boat","MAX_SPEED","currentPathIndex","currentPath","currentNode","nextX","nextY","speed","targetSpeed","updateWaypoint","moveTowards","dist","beforeX","beforeY","boatManager","unregisterBoat","calculateSpeed","currentX","currentY","getWaypoint","atan2","distToNext","exp","beginPath","arc","findPathInArea","end","startX","startY","costMap","onNeighborWater","newCost","findStartsInArea","distanceMap","findPlayerTile","checkX","checkY","boats","requestBoat","coast","findCoastNear","inSameArea","costs","startPoints","foundCost","edge","findStartingPoint","addBoat","sign","startAreaId","parents","last","calculateBoatWaypoints","piece","boat","mapActionHandler","setAction","action","FixedDistanceShader","toRGB","apply","blendWithBuffer","DynamicDistanceShader","gradient","shaderList","type","build","thickness","activePostGeneration","addPostGenerationShader","shader","mapRenderer","shaderData","getShaderArgs","obj","loadShaders","imageData","getImageData","tileColors","getTileColor","writeToBuffer","applyPostGenerationShaders","putImageData","windowResizeHandler","devicePixelRatio","backgroundLayer","getBackgroundColor","nameRenderer","xMin","xMax","yMin","yMax","boatRenderer","gameRenderer","layers","position","left","top","zIndex","doRenderTick","appendChild","initGameplayLayers","registerLayer","layer","imageSmoothingEnabled","requestAnimationFrame","resize","ZoneCalculator","buildZones","zone","calculateZones","tileMap","leftBorder","leftBorderMap","topBorder","topBorderMap","zoneTiles","zoneCache","findZone","topType","leftType","topZone","leftZone","mergeZones","into","MapEncoder","writeCompressed","writer","writeBits","zones","typeMap","nextTypeId","typeLength","log2","Object","keys","lines","calculateLines","writeTypeMap","writeLines","typeMapLength","currentChunk","line","checkChunk","diff","chunkX","chunk","chunkLines","chunkWidth","chunkMap","chunkY","sort","linesL2R","linesT2B","calculateNeededLines","costL2R","calculateCost","costT2B","writeBoolean","pointMap","segments","segmentMap","connectionCount","connectionMap","calculateConnections","depth","connection","to","processConnection","cropLines","addSingles","segment","fromIsNew","toIsNew","valueFrom","valueTo","concatSegment","reverse","connectSegments","ending","toAdd","segmentA","segmentB","startA","startB","calculatePaths","open","visited","shift","nextPoint","StreamReader","buffer","readBits","Error","readString","maxLength","String","fromCharCode","readBoolean","mapDecoder","readCompressed","reader","direction","readTypeMap","valueMap","putLines","fillLinesTopToBottom","fillLinesLeftToRight","lineCount","GameMap","Int16Array","setTileId","calculateDistanceMap","increaseDistance","distance1","distance2","mapRegistry","registerMap","base64Data","atob","c","charCodeAt","GameMode","_player","FFAGameMode","txtPlayerName","lblPlayerNameValidation","btnStart","playerNameValidationExp","savedPlayerName","commandStartGame","mode","decoded","version","decodeMap","mapFromId","commandShowCommunity","commandShowImprint","commandShowPrivacy","commandUpdateName","disabled","commandClosePrivacyPanel","switchGameClock","checked","commandToggleClockSetting","commandCloseSettingsPanel","RGBColor","r","g","strength","withRed","withGreen","withBlue","withAlpha","h","s","toRGBComponent","withHue","withSaturation","withLightness","divisor","hue","component","k","round","fromRGBA","fromRGBColor","formatTroops","padStart","formatTime","time","pad","n","z","minutes","seconds","milliseconds","SettingRegistry","updaters","setting","registerUpdatable","defaultValue","decode","encode","decodeUpdatable","applyUpdaters","oldVer","updater","saveSetting","registerString","registerNumber","parseFloat","registerInteger","parseInt","registerBoolean","registerUpdater","load","localStorage","setItem","getAll","getTheme","tileOverrides","originalGetTileColor","registerTheme","getSetting","updateSetting","registerSettingListener","message","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","__webpack_modules__","d","definition","o","defineProperty","enumerable","prop","prototype","hasOwnProperty"],"sourceRoot":""}}]}